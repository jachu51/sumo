   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"stm32f10x_adc.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.align	2
  19              		.global	ADC_DeInit
  20              		.thumb
  21              		.thumb_func
  23              	ADC_DeInit:
  24              	.LFB29:
  25              		.file 1 "../src/stm32f10x_adc.c"
   1:../src/stm32f10x_adc.c **** /**
   2:../src/stm32f10x_adc.c ****   ******************************************************************************
   3:../src/stm32f10x_adc.c ****   * @file    stm32f10x_adc.c
   4:../src/stm32f10x_adc.c ****   * @author  MCD Application Team
   5:../src/stm32f10x_adc.c ****   * @version V3.5.0
   6:../src/stm32f10x_adc.c ****   * @date    11-March-2011
   7:../src/stm32f10x_adc.c ****   * @brief   This file provides all the ADC firmware functions.
   8:../src/stm32f10x_adc.c ****   ******************************************************************************
   9:../src/stm32f10x_adc.c ****   * @attention
  10:../src/stm32f10x_adc.c ****   *
  11:../src/stm32f10x_adc.c ****   * THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
  12:../src/stm32f10x_adc.c ****   * WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE
  13:../src/stm32f10x_adc.c ****   * TIME. AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY
  14:../src/stm32f10x_adc.c ****   * DIRECT, INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING
  15:../src/stm32f10x_adc.c ****   * FROM THE CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE
  16:../src/stm32f10x_adc.c ****   * CODING INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
  17:../src/stm32f10x_adc.c ****   *
  18:../src/stm32f10x_adc.c ****   * <h2><center>&copy; COPYRIGHT 2011 STMicroelectronics</center></h2>
  19:../src/stm32f10x_adc.c ****   ******************************************************************************
  20:../src/stm32f10x_adc.c ****   */
  21:../src/stm32f10x_adc.c **** 
  22:../src/stm32f10x_adc.c **** /* Includes ------------------------------------------------------------------*/
  23:../src/stm32f10x_adc.c **** #include "stm32f10x_adc.h"
  24:../src/stm32f10x_adc.c **** #include "stm32f10x_rcc.h"
  25:../src/stm32f10x_adc.c **** #include "stm32f10x_conf.h"
  26:../src/stm32f10x_adc.c **** 
  27:../src/stm32f10x_adc.c **** /** @addtogroup STM32F10x_StdPeriph_Driver
  28:../src/stm32f10x_adc.c ****   * @{
  29:../src/stm32f10x_adc.c ****   */
  30:../src/stm32f10x_adc.c **** 
  31:../src/stm32f10x_adc.c **** /** @defgroup ADC 
  32:../src/stm32f10x_adc.c ****   * @brief ADC driver modules
  33:../src/stm32f10x_adc.c ****   * @{
  34:../src/stm32f10x_adc.c ****   */
  35:../src/stm32f10x_adc.c **** 
  36:../src/stm32f10x_adc.c **** /** @defgroup ADC_Private_TypesDefinitions
  37:../src/stm32f10x_adc.c ****   * @{
  38:../src/stm32f10x_adc.c ****   */
  39:../src/stm32f10x_adc.c **** 
  40:../src/stm32f10x_adc.c **** /**
  41:../src/stm32f10x_adc.c ****   * @}
  42:../src/stm32f10x_adc.c ****   */
  43:../src/stm32f10x_adc.c **** 
  44:../src/stm32f10x_adc.c **** /** @defgroup ADC_Private_Defines
  45:../src/stm32f10x_adc.c ****   * @{
  46:../src/stm32f10x_adc.c ****   */
  47:../src/stm32f10x_adc.c **** 
  48:../src/stm32f10x_adc.c **** /* ADC DISCNUM mask */
  49:../src/stm32f10x_adc.c **** #define CR1_DISCNUM_Reset           ((uint32_t)0xFFFF1FFF)
  50:../src/stm32f10x_adc.c **** 
  51:../src/stm32f10x_adc.c **** /* ADC DISCEN mask */
  52:../src/stm32f10x_adc.c **** #define CR1_DISCEN_Set              ((uint32_t)0x00000800)
  53:../src/stm32f10x_adc.c **** #define CR1_DISCEN_Reset            ((uint32_t)0xFFFFF7FF)
  54:../src/stm32f10x_adc.c **** 
  55:../src/stm32f10x_adc.c **** /* ADC JAUTO mask */
  56:../src/stm32f10x_adc.c **** #define CR1_JAUTO_Set               ((uint32_t)0x00000400)
  57:../src/stm32f10x_adc.c **** #define CR1_JAUTO_Reset             ((uint32_t)0xFFFFFBFF)
  58:../src/stm32f10x_adc.c **** 
  59:../src/stm32f10x_adc.c **** /* ADC JDISCEN mask */
  60:../src/stm32f10x_adc.c **** #define CR1_JDISCEN_Set             ((uint32_t)0x00001000)
  61:../src/stm32f10x_adc.c **** #define CR1_JDISCEN_Reset           ((uint32_t)0xFFFFEFFF)
  62:../src/stm32f10x_adc.c **** 
  63:../src/stm32f10x_adc.c **** /* ADC AWDCH mask */
  64:../src/stm32f10x_adc.c **** #define CR1_AWDCH_Reset             ((uint32_t)0xFFFFFFE0)
  65:../src/stm32f10x_adc.c **** 
  66:../src/stm32f10x_adc.c **** /* ADC Analog watchdog enable mode mask */
  67:../src/stm32f10x_adc.c **** #define CR1_AWDMode_Reset           ((uint32_t)0xFF3FFDFF)
  68:../src/stm32f10x_adc.c **** 
  69:../src/stm32f10x_adc.c **** /* CR1 register Mask */
  70:../src/stm32f10x_adc.c **** #define CR1_CLEAR_Mask              ((uint32_t)0xFFF0FEFF)
  71:../src/stm32f10x_adc.c **** 
  72:../src/stm32f10x_adc.c **** /* ADC ADON mask */
  73:../src/stm32f10x_adc.c **** #define CR2_ADON_Set                ((uint32_t)0x00000001)
  74:../src/stm32f10x_adc.c **** #define CR2_ADON_Reset              ((uint32_t)0xFFFFFFFE)
  75:../src/stm32f10x_adc.c **** 
  76:../src/stm32f10x_adc.c **** /* ADC DMA mask */
  77:../src/stm32f10x_adc.c **** #define CR2_DMA_Set                 ((uint32_t)0x00000100)
  78:../src/stm32f10x_adc.c **** #define CR2_DMA_Reset               ((uint32_t)0xFFFFFEFF)
  79:../src/stm32f10x_adc.c **** 
  80:../src/stm32f10x_adc.c **** /* ADC RSTCAL mask */
  81:../src/stm32f10x_adc.c **** #define CR2_RSTCAL_Set              ((uint32_t)0x00000008)
  82:../src/stm32f10x_adc.c **** 
  83:../src/stm32f10x_adc.c **** /* ADC CAL mask */
  84:../src/stm32f10x_adc.c **** #define CR2_CAL_Set                 ((uint32_t)0x00000004)
  85:../src/stm32f10x_adc.c **** 
  86:../src/stm32f10x_adc.c **** /* ADC SWSTART mask */
  87:../src/stm32f10x_adc.c **** #define CR2_SWSTART_Set             ((uint32_t)0x00400000)
  88:../src/stm32f10x_adc.c **** 
  89:../src/stm32f10x_adc.c **** /* ADC EXTTRIG mask */
  90:../src/stm32f10x_adc.c **** #define CR2_EXTTRIG_Set             ((uint32_t)0x00100000)
  91:../src/stm32f10x_adc.c **** #define CR2_EXTTRIG_Reset           ((uint32_t)0xFFEFFFFF)
  92:../src/stm32f10x_adc.c **** 
  93:../src/stm32f10x_adc.c **** /* ADC Software start mask */
  94:../src/stm32f10x_adc.c **** #define CR2_EXTTRIG_SWSTART_Set     ((uint32_t)0x00500000)
  95:../src/stm32f10x_adc.c **** #define CR2_EXTTRIG_SWSTART_Reset   ((uint32_t)0xFFAFFFFF)
  96:../src/stm32f10x_adc.c **** 
  97:../src/stm32f10x_adc.c **** /* ADC JEXTSEL mask */
  98:../src/stm32f10x_adc.c **** #define CR2_JEXTSEL_Reset           ((uint32_t)0xFFFF8FFF)
  99:../src/stm32f10x_adc.c **** 
 100:../src/stm32f10x_adc.c **** /* ADC JEXTTRIG mask */
 101:../src/stm32f10x_adc.c **** #define CR2_JEXTTRIG_Set            ((uint32_t)0x00008000)
 102:../src/stm32f10x_adc.c **** #define CR2_JEXTTRIG_Reset          ((uint32_t)0xFFFF7FFF)
 103:../src/stm32f10x_adc.c **** 
 104:../src/stm32f10x_adc.c **** /* ADC JSWSTART mask */
 105:../src/stm32f10x_adc.c **** #define CR2_JSWSTART_Set            ((uint32_t)0x00200000)
 106:../src/stm32f10x_adc.c **** 
 107:../src/stm32f10x_adc.c **** /* ADC injected software start mask */
 108:../src/stm32f10x_adc.c **** #define CR2_JEXTTRIG_JSWSTART_Set   ((uint32_t)0x00208000)
 109:../src/stm32f10x_adc.c **** #define CR2_JEXTTRIG_JSWSTART_Reset ((uint32_t)0xFFDF7FFF)
 110:../src/stm32f10x_adc.c **** 
 111:../src/stm32f10x_adc.c **** /* ADC TSPD mask */
 112:../src/stm32f10x_adc.c **** #define CR2_TSVREFE_Set             ((uint32_t)0x00800000)
 113:../src/stm32f10x_adc.c **** #define CR2_TSVREFE_Reset           ((uint32_t)0xFF7FFFFF)
 114:../src/stm32f10x_adc.c **** 
 115:../src/stm32f10x_adc.c **** /* CR2 register Mask */
 116:../src/stm32f10x_adc.c **** #define CR2_CLEAR_Mask              ((uint32_t)0xFFF1F7FD)
 117:../src/stm32f10x_adc.c **** 
 118:../src/stm32f10x_adc.c **** /* ADC SQx mask */
 119:../src/stm32f10x_adc.c **** #define SQR3_SQ_Set                 ((uint32_t)0x0000001F)
 120:../src/stm32f10x_adc.c **** #define SQR2_SQ_Set                 ((uint32_t)0x0000001F)
 121:../src/stm32f10x_adc.c **** #define SQR1_SQ_Set                 ((uint32_t)0x0000001F)
 122:../src/stm32f10x_adc.c **** 
 123:../src/stm32f10x_adc.c **** /* SQR1 register Mask */
 124:../src/stm32f10x_adc.c **** #define SQR1_CLEAR_Mask             ((uint32_t)0xFF0FFFFF)
 125:../src/stm32f10x_adc.c **** 
 126:../src/stm32f10x_adc.c **** /* ADC JSQx mask */
 127:../src/stm32f10x_adc.c **** #define JSQR_JSQ_Set                ((uint32_t)0x0000001F)
 128:../src/stm32f10x_adc.c **** 
 129:../src/stm32f10x_adc.c **** /* ADC JL mask */
 130:../src/stm32f10x_adc.c **** #define JSQR_JL_Set                 ((uint32_t)0x00300000)
 131:../src/stm32f10x_adc.c **** #define JSQR_JL_Reset               ((uint32_t)0xFFCFFFFF)
 132:../src/stm32f10x_adc.c **** 
 133:../src/stm32f10x_adc.c **** /* ADC SMPx mask */
 134:../src/stm32f10x_adc.c **** #define SMPR1_SMP_Set               ((uint32_t)0x00000007)
 135:../src/stm32f10x_adc.c **** #define SMPR2_SMP_Set               ((uint32_t)0x00000007)
 136:../src/stm32f10x_adc.c **** 
 137:../src/stm32f10x_adc.c **** /* ADC JDRx registers offset */
 138:../src/stm32f10x_adc.c **** #define JDR_Offset                  ((uint8_t)0x28)
 139:../src/stm32f10x_adc.c **** 
 140:../src/stm32f10x_adc.c **** /* ADC1 DR register base address */
 141:../src/stm32f10x_adc.c **** #define DR_ADDRESS                  ((uint32_t)0x4001244C)
 142:../src/stm32f10x_adc.c **** 
 143:../src/stm32f10x_adc.c **** /**
 144:../src/stm32f10x_adc.c ****   * @}
 145:../src/stm32f10x_adc.c ****   */
 146:../src/stm32f10x_adc.c **** 
 147:../src/stm32f10x_adc.c **** /** @defgroup ADC_Private_Macros
 148:../src/stm32f10x_adc.c ****   * @{
 149:../src/stm32f10x_adc.c ****   */
 150:../src/stm32f10x_adc.c **** 
 151:../src/stm32f10x_adc.c **** /**
 152:../src/stm32f10x_adc.c ****   * @}
 153:../src/stm32f10x_adc.c ****   */
 154:../src/stm32f10x_adc.c **** 
 155:../src/stm32f10x_adc.c **** /** @defgroup ADC_Private_Variables
 156:../src/stm32f10x_adc.c ****   * @{
 157:../src/stm32f10x_adc.c ****   */
 158:../src/stm32f10x_adc.c **** 
 159:../src/stm32f10x_adc.c **** /**
 160:../src/stm32f10x_adc.c ****   * @}
 161:../src/stm32f10x_adc.c ****   */
 162:../src/stm32f10x_adc.c **** 
 163:../src/stm32f10x_adc.c **** /** @defgroup ADC_Private_FunctionPrototypes
 164:../src/stm32f10x_adc.c ****   * @{
 165:../src/stm32f10x_adc.c ****   */
 166:../src/stm32f10x_adc.c **** 
 167:../src/stm32f10x_adc.c **** /**
 168:../src/stm32f10x_adc.c ****   * @}
 169:../src/stm32f10x_adc.c ****   */
 170:../src/stm32f10x_adc.c **** 
 171:../src/stm32f10x_adc.c **** /** @defgroup ADC_Private_Functions
 172:../src/stm32f10x_adc.c ****   * @{
 173:../src/stm32f10x_adc.c ****   */
 174:../src/stm32f10x_adc.c **** 
 175:../src/stm32f10x_adc.c **** /**
 176:../src/stm32f10x_adc.c ****   * @brief  Deinitializes the ADCx peripheral registers to their default reset values.
 177:../src/stm32f10x_adc.c ****   * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
 178:../src/stm32f10x_adc.c ****   * @retval None
 179:../src/stm32f10x_adc.c ****   */
 180:../src/stm32f10x_adc.c **** void ADC_DeInit(ADC_TypeDef* ADCx)
 181:../src/stm32f10x_adc.c **** {
  26              		.loc 1 181 0
  27              		.cfi_startproc
  28              		@ args = 0, pretend = 0, frame = 8
  29              		@ frame_needed = 1, uses_anonymous_args = 0
  30 0000 80B5     		push	{r7, lr}
  31              	.LCFI0:
  32              		.cfi_def_cfa_offset 8
  33              		.cfi_offset 14, -4
  34              		.cfi_offset 7, -8
  35 0002 82B0     		sub	sp, sp, #8
  36              	.LCFI1:
  37              		.cfi_def_cfa_offset 16
  38 0004 00AF     		add	r7, sp, #0
  39              	.LCFI2:
  40              		.cfi_def_cfa_register 7
  41 0006 7860     		str	r0, [r7, #4]
 182:../src/stm32f10x_adc.c ****   /* Check the parameters */
 183:../src/stm32f10x_adc.c ****   assert_param(IS_ADC_ALL_PERIPH(ADCx));
 184:../src/stm32f10x_adc.c ****   
 185:../src/stm32f10x_adc.c ****   if (ADCx == ADC1)
  42              		.loc 1 185 0
  43 0008 7A68     		ldr	r2, [r7, #4]
  44 000a 4FF41053 		mov	r3, #9216
  45 000e C4F20103 		movt	r3, 16385
  46 0012 9A42     		cmp	r2, r3
  47 0014 0CD1     		bne	.L2
 186:../src/stm32f10x_adc.c ****   {
 187:../src/stm32f10x_adc.c ****     /* Enable ADC1 reset state */
 188:../src/stm32f10x_adc.c ****     RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, ENABLE);
  48              		.loc 1 188 0
  49 0016 4FF40070 		mov	r0, #512
  50 001a 4FF00101 		mov	r1, #1
  51 001e FFF7FEFF 		bl	RCC_APB2PeriphResetCmd
 189:../src/stm32f10x_adc.c ****     /* Release ADC1 from reset state */
 190:../src/stm32f10x_adc.c ****     RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, DISABLE);
  52              		.loc 1 190 0
  53 0022 4FF40070 		mov	r0, #512
  54 0026 4FF00001 		mov	r1, #0
  55 002a FFF7FEFF 		bl	RCC_APB2PeriphResetCmd
  56 002e 26E0     		b	.L1
  57              	.L2:
 191:../src/stm32f10x_adc.c ****   }
 192:../src/stm32f10x_adc.c ****   else if (ADCx == ADC2)
  58              		.loc 1 192 0
  59 0030 7A68     		ldr	r2, [r7, #4]
  60 0032 4FF42053 		mov	r3, #10240
  61 0036 C4F20103 		movt	r3, 16385
  62 003a 9A42     		cmp	r2, r3
  63 003c 0CD1     		bne	.L4
 193:../src/stm32f10x_adc.c ****   {
 194:../src/stm32f10x_adc.c ****     /* Enable ADC2 reset state */
 195:../src/stm32f10x_adc.c ****     RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC2, ENABLE);
  64              		.loc 1 195 0
  65 003e 4FF48060 		mov	r0, #1024
  66 0042 4FF00101 		mov	r1, #1
  67 0046 FFF7FEFF 		bl	RCC_APB2PeriphResetCmd
 196:../src/stm32f10x_adc.c ****     /* Release ADC2 from reset state */
 197:../src/stm32f10x_adc.c ****     RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC2, DISABLE);
  68              		.loc 1 197 0
  69 004a 4FF48060 		mov	r0, #1024
  70 004e 4FF00001 		mov	r1, #0
  71 0052 FFF7FEFF 		bl	RCC_APB2PeriphResetCmd
  72 0056 12E0     		b	.L1
  73              	.L4:
 198:../src/stm32f10x_adc.c ****   }
 199:../src/stm32f10x_adc.c ****   else
 200:../src/stm32f10x_adc.c ****   {
 201:../src/stm32f10x_adc.c ****     if (ADCx == ADC3)
  74              		.loc 1 201 0
  75 0058 7A68     		ldr	r2, [r7, #4]
  76 005a 4FF47053 		mov	r3, #15360
  77 005e C4F20103 		movt	r3, 16385
  78 0062 9A42     		cmp	r2, r3
  79 0064 0BD1     		bne	.L1
 202:../src/stm32f10x_adc.c ****     {
 203:../src/stm32f10x_adc.c ****       /* Enable ADC3 reset state */
 204:../src/stm32f10x_adc.c ****       RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC3, ENABLE);
  80              		.loc 1 204 0
  81 0066 4FF40040 		mov	r0, #32768
  82 006a 4FF00101 		mov	r1, #1
  83 006e FFF7FEFF 		bl	RCC_APB2PeriphResetCmd
 205:../src/stm32f10x_adc.c ****       /* Release ADC3 from reset state */
 206:../src/stm32f10x_adc.c ****       RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC3, DISABLE);
  84              		.loc 1 206 0
  85 0072 4FF40040 		mov	r0, #32768
  86 0076 4FF00001 		mov	r1, #0
  87 007a FFF7FEFF 		bl	RCC_APB2PeriphResetCmd
  88              	.L1:
 207:../src/stm32f10x_adc.c ****     }
 208:../src/stm32f10x_adc.c ****   }
 209:../src/stm32f10x_adc.c **** }
  89              		.loc 1 209 0
  90 007e 07F10807 		add	r7, r7, #8
  91 0082 BD46     		mov	sp, r7
  92 0084 80BD     		pop	{r7, pc}
  93              		.cfi_endproc
  94              	.LFE29:
  96 0086 00BF     		.align	2
  97              		.global	ADC_Init
  98              		.thumb
  99              		.thumb_func
 101              	ADC_Init:
 102              	.LFB30:
 210:../src/stm32f10x_adc.c **** 
 211:../src/stm32f10x_adc.c **** /**
 212:../src/stm32f10x_adc.c ****   * @brief  Initializes the ADCx peripheral according to the specified parameters
 213:../src/stm32f10x_adc.c ****   *         in the ADC_InitStruct.
 214:../src/stm32f10x_adc.c ****   * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
 215:../src/stm32f10x_adc.c ****   * @param  ADC_InitStruct: pointer to an ADC_InitTypeDef structure that contains
 216:../src/stm32f10x_adc.c ****   *         the configuration information for the specified ADC peripheral.
 217:../src/stm32f10x_adc.c ****   * @retval None
 218:../src/stm32f10x_adc.c ****   */
 219:../src/stm32f10x_adc.c **** void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct)
 220:../src/stm32f10x_adc.c **** {
 103              		.loc 1 220 0
 104              		.cfi_startproc
 105              		@ args = 0, pretend = 0, frame = 16
 106              		@ frame_needed = 1, uses_anonymous_args = 0
 107              		@ link register save eliminated.
 108 0088 80B4     		push	{r7}
 109              	.LCFI3:
 110              		.cfi_def_cfa_offset 4
 111              		.cfi_offset 7, -4
 112 008a 85B0     		sub	sp, sp, #20
 113              	.LCFI4:
 114              		.cfi_def_cfa_offset 24
 115 008c 00AF     		add	r7, sp, #0
 116              	.LCFI5:
 117              		.cfi_def_cfa_register 7
 118 008e 7860     		str	r0, [r7, #4]
 119 0090 3960     		str	r1, [r7, #0]
 221:../src/stm32f10x_adc.c ****   uint32_t tmpreg1 = 0;
 120              		.loc 1 221 0
 121 0092 4FF00003 		mov	r3, #0
 122 0096 FB60     		str	r3, [r7, #12]
 222:../src/stm32f10x_adc.c ****   uint8_t tmpreg2 = 0;
 123              		.loc 1 222 0
 124 0098 4FF00003 		mov	r3, #0
 125 009c FB72     		strb	r3, [r7, #11]
 223:../src/stm32f10x_adc.c ****   /* Check the parameters */
 224:../src/stm32f10x_adc.c ****   assert_param(IS_ADC_ALL_PERIPH(ADCx));
 225:../src/stm32f10x_adc.c ****   assert_param(IS_ADC_MODE(ADC_InitStruct->ADC_Mode));
 226:../src/stm32f10x_adc.c ****   assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ScanConvMode));
 227:../src/stm32f10x_adc.c ****   assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ContinuousConvMode));
 228:../src/stm32f10x_adc.c ****   assert_param(IS_ADC_EXT_TRIG(ADC_InitStruct->ADC_ExternalTrigConv));   
 229:../src/stm32f10x_adc.c ****   assert_param(IS_ADC_DATA_ALIGN(ADC_InitStruct->ADC_DataAlign)); 
 230:../src/stm32f10x_adc.c ****   assert_param(IS_ADC_REGULAR_LENGTH(ADC_InitStruct->ADC_NbrOfChannel));
 231:../src/stm32f10x_adc.c **** 
 232:../src/stm32f10x_adc.c ****   /*---------------------------- ADCx CR1 Configuration -----------------*/
 233:../src/stm32f10x_adc.c ****   /* Get the ADCx CR1 value */
 234:../src/stm32f10x_adc.c ****   tmpreg1 = ADCx->CR1;
 126              		.loc 1 234 0
 127 009e 7B68     		ldr	r3, [r7, #4]
 128 00a0 5B68     		ldr	r3, [r3, #4]
 129 00a2 FB60     		str	r3, [r7, #12]
 235:../src/stm32f10x_adc.c ****   /* Clear DUALMOD and SCAN bits */
 236:../src/stm32f10x_adc.c ****   tmpreg1 &= CR1_CLEAR_Mask;
 130              		.loc 1 236 0
 131 00a4 FB68     		ldr	r3, [r7, #12]
 132 00a6 23F47023 		bic	r3, r3, #983040
 133 00aa 23F48073 		bic	r3, r3, #256
 134 00ae FB60     		str	r3, [r7, #12]
 237:../src/stm32f10x_adc.c ****   /* Configure ADCx: Dual mode and scan conversion mode */
 238:../src/stm32f10x_adc.c ****   /* Set DUALMOD bits according to ADC_Mode value */
 239:../src/stm32f10x_adc.c ****   /* Set SCAN bit according to ADC_ScanConvMode value */
 240:../src/stm32f10x_adc.c ****   tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_Mode | ((uint32_t)ADC_InitStruct->ADC_ScanConvMode << 8
 135              		.loc 1 240 0
 136 00b0 3B68     		ldr	r3, [r7, #0]
 137 00b2 1A68     		ldr	r2, [r3, #0]
 138 00b4 3B68     		ldr	r3, [r7, #0]
 139 00b6 1B79     		ldrb	r3, [r3, #4]	@ zero_extendqisi2
 140 00b8 4FEA0323 		lsl	r3, r3, #8
 141 00bc 1343     		orrs	r3, r3, r2
 142 00be FA68     		ldr	r2, [r7, #12]
 143 00c0 1343     		orrs	r3, r3, r2
 144 00c2 FB60     		str	r3, [r7, #12]
 241:../src/stm32f10x_adc.c ****   /* Write to ADCx CR1 */
 242:../src/stm32f10x_adc.c ****   ADCx->CR1 = tmpreg1;
 145              		.loc 1 242 0
 146 00c4 7B68     		ldr	r3, [r7, #4]
 147 00c6 FA68     		ldr	r2, [r7, #12]
 148 00c8 5A60     		str	r2, [r3, #4]
 243:../src/stm32f10x_adc.c **** 
 244:../src/stm32f10x_adc.c ****   /*---------------------------- ADCx CR2 Configuration -----------------*/
 245:../src/stm32f10x_adc.c ****   /* Get the ADCx CR2 value */
 246:../src/stm32f10x_adc.c ****   tmpreg1 = ADCx->CR2;
 149              		.loc 1 246 0
 150 00ca 7B68     		ldr	r3, [r7, #4]
 151 00cc 9B68     		ldr	r3, [r3, #8]
 152 00ce FB60     		str	r3, [r7, #12]
 247:../src/stm32f10x_adc.c ****   /* Clear CONT, ALIGN and EXTSEL bits */
 248:../src/stm32f10x_adc.c ****   tmpreg1 &= CR2_CLEAR_Mask;
 153              		.loc 1 248 0
 154 00d0 FA68     		ldr	r2, [r7, #12]
 155 00d2 4FF2FD73 		movw	r3, #63485
 156 00d6 CFF6F173 		movt	r3, 65521
 157 00da 1340     		ands	r3, r3, r2
 158 00dc FB60     		str	r3, [r7, #12]
 249:../src/stm32f10x_adc.c ****   /* Configure ADCx: external trigger event and continuous conversion mode */
 250:../src/stm32f10x_adc.c ****   /* Set ALIGN bit according to ADC_DataAlign value */
 251:../src/stm32f10x_adc.c ****   /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
 252:../src/stm32f10x_adc.c ****   /* Set CONT bit according to ADC_ContinuousConvMode value */
 253:../src/stm32f10x_adc.c ****   tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | ADC_InitStruct->ADC_ExternalTrigConv |
 159              		.loc 1 253 0
 160 00de 3B68     		ldr	r3, [r7, #0]
 161 00e0 DA68     		ldr	r2, [r3, #12]
 162 00e2 3B68     		ldr	r3, [r7, #0]
 163 00e4 9B68     		ldr	r3, [r3, #8]
 164 00e6 1A43     		orrs	r2, r2, r3
 254:../src/stm32f10x_adc.c ****             ((uint32_t)ADC_InitStruct->ADC_ContinuousConvMode << 1));
 165              		.loc 1 254 0
 166 00e8 3B68     		ldr	r3, [r7, #0]
 167 00ea 5B79     		ldrb	r3, [r3, #5]	@ zero_extendqisi2
 168 00ec 4FEA4303 		lsl	r3, r3, #1
 253:../src/stm32f10x_adc.c ****   tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | ADC_InitStruct->ADC_ExternalTrigConv |
 169              		.loc 1 253 0
 170 00f0 1343     		orrs	r3, r3, r2
 171 00f2 FA68     		ldr	r2, [r7, #12]
 172 00f4 1343     		orrs	r3, r3, r2
 173 00f6 FB60     		str	r3, [r7, #12]
 255:../src/stm32f10x_adc.c ****   /* Write to ADCx CR2 */
 256:../src/stm32f10x_adc.c ****   ADCx->CR2 = tmpreg1;
 174              		.loc 1 256 0
 175 00f8 7B68     		ldr	r3, [r7, #4]
 176 00fa FA68     		ldr	r2, [r7, #12]
 177 00fc 9A60     		str	r2, [r3, #8]
 257:../src/stm32f10x_adc.c **** 
 258:../src/stm32f10x_adc.c ****   /*---------------------------- ADCx SQR1 Configuration -----------------*/
 259:../src/stm32f10x_adc.c ****   /* Get the ADCx SQR1 value */
 260:../src/stm32f10x_adc.c ****   tmpreg1 = ADCx->SQR1;
 178              		.loc 1 260 0
 179 00fe 7B68     		ldr	r3, [r7, #4]
 180 0100 DB6A     		ldr	r3, [r3, #44]
 181 0102 FB60     		str	r3, [r7, #12]
 261:../src/stm32f10x_adc.c ****   /* Clear L bits */
 262:../src/stm32f10x_adc.c ****   tmpreg1 &= SQR1_CLEAR_Mask;
 182              		.loc 1 262 0
 183 0104 FB68     		ldr	r3, [r7, #12]
 184 0106 23F47003 		bic	r3, r3, #15728640
 185 010a FB60     		str	r3, [r7, #12]
 263:../src/stm32f10x_adc.c ****   /* Configure ADCx: regular channel sequence length */
 264:../src/stm32f10x_adc.c ****   /* Set L bits according to ADC_NbrOfChannel value */
 265:../src/stm32f10x_adc.c ****   tmpreg2 |= (uint8_t) (ADC_InitStruct->ADC_NbrOfChannel - (uint8_t)1);
 186              		.loc 1 265 0
 187 010c 3B68     		ldr	r3, [r7, #0]
 188 010e 1B7C     		ldrb	r3, [r3, #16]	@ zero_extendqisi2
 189 0110 03F1FF33 		add	r3, r3, #-1
 190 0114 DAB2     		uxtb	r2, r3
 191 0116 FB7A     		ldrb	r3, [r7, #11]
 192 0118 1343     		orrs	r3, r3, r2
 193 011a FB72     		strb	r3, [r7, #11]
 266:../src/stm32f10x_adc.c ****   tmpreg1 |= (uint32_t)tmpreg2 << 20;
 194              		.loc 1 266 0
 195 011c FB7A     		ldrb	r3, [r7, #11]	@ zero_extendqisi2
 196 011e 4FEA0353 		lsl	r3, r3, #20
 197 0122 FA68     		ldr	r2, [r7, #12]
 198 0124 1343     		orrs	r3, r3, r2
 199 0126 FB60     		str	r3, [r7, #12]
 267:../src/stm32f10x_adc.c ****   /* Write to ADCx SQR1 */
 268:../src/stm32f10x_adc.c ****   ADCx->SQR1 = tmpreg1;
 200              		.loc 1 268 0
 201 0128 7B68     		ldr	r3, [r7, #4]
 202 012a FA68     		ldr	r2, [r7, #12]
 203 012c DA62     		str	r2, [r3, #44]
 269:../src/stm32f10x_adc.c **** }
 204              		.loc 1 269 0
 205 012e 07F11407 		add	r7, r7, #20
 206 0132 BD46     		mov	sp, r7
 207 0134 80BC     		pop	{r7}
 208 0136 7047     		bx	lr
 209              		.cfi_endproc
 210              	.LFE30:
 212              		.align	2
 213              		.global	ADC_StructInit
 214              		.thumb
 215              		.thumb_func
 217              	ADC_StructInit:
 218              	.LFB31:
 270:../src/stm32f10x_adc.c **** 
 271:../src/stm32f10x_adc.c **** /**
 272:../src/stm32f10x_adc.c ****   * @brief  Fills each ADC_InitStruct member with its default value.
 273:../src/stm32f10x_adc.c ****   * @param  ADC_InitStruct : pointer to an ADC_InitTypeDef structure which will be initialized.
 274:../src/stm32f10x_adc.c ****   * @retval None
 275:../src/stm32f10x_adc.c ****   */
 276:../src/stm32f10x_adc.c **** void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct)
 277:../src/stm32f10x_adc.c **** {
 219              		.loc 1 277 0
 220              		.cfi_startproc
 221              		@ args = 0, pretend = 0, frame = 8
 222              		@ frame_needed = 1, uses_anonymous_args = 0
 223              		@ link register save eliminated.
 224 0138 80B4     		push	{r7}
 225              	.LCFI6:
 226              		.cfi_def_cfa_offset 4
 227              		.cfi_offset 7, -4
 228 013a 83B0     		sub	sp, sp, #12
 229              	.LCFI7:
 230              		.cfi_def_cfa_offset 16
 231 013c 00AF     		add	r7, sp, #0
 232              	.LCFI8:
 233              		.cfi_def_cfa_register 7
 234 013e 7860     		str	r0, [r7, #4]
 278:../src/stm32f10x_adc.c ****   /* Reset ADC init structure parameters values */
 279:../src/stm32f10x_adc.c ****   /* Initialize the ADC_Mode member */
 280:../src/stm32f10x_adc.c ****   ADC_InitStruct->ADC_Mode = ADC_Mode_Independent;
 235              		.loc 1 280 0
 236 0140 7B68     		ldr	r3, [r7, #4]
 237 0142 4FF00002 		mov	r2, #0
 238 0146 1A60     		str	r2, [r3, #0]
 281:../src/stm32f10x_adc.c ****   /* initialize the ADC_ScanConvMode member */
 282:../src/stm32f10x_adc.c ****   ADC_InitStruct->ADC_ScanConvMode = DISABLE;
 239              		.loc 1 282 0
 240 0148 7B68     		ldr	r3, [r7, #4]
 241 014a 4FF00002 		mov	r2, #0
 242 014e 1A71     		strb	r2, [r3, #4]
 283:../src/stm32f10x_adc.c ****   /* Initialize the ADC_ContinuousConvMode member */
 284:../src/stm32f10x_adc.c ****   ADC_InitStruct->ADC_ContinuousConvMode = DISABLE;
 243              		.loc 1 284 0
 244 0150 7B68     		ldr	r3, [r7, #4]
 245 0152 4FF00002 		mov	r2, #0
 246 0156 5A71     		strb	r2, [r3, #5]
 285:../src/stm32f10x_adc.c ****   /* Initialize the ADC_ExternalTrigConv member */
 286:../src/stm32f10x_adc.c ****   ADC_InitStruct->ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC1;
 247              		.loc 1 286 0
 248 0158 7B68     		ldr	r3, [r7, #4]
 249 015a 4FF00002 		mov	r2, #0
 250 015e 9A60     		str	r2, [r3, #8]
 287:../src/stm32f10x_adc.c ****   /* Initialize the ADC_DataAlign member */
 288:../src/stm32f10x_adc.c ****   ADC_InitStruct->ADC_DataAlign = ADC_DataAlign_Right;
 251              		.loc 1 288 0
 252 0160 7B68     		ldr	r3, [r7, #4]
 253 0162 4FF00002 		mov	r2, #0
 254 0166 DA60     		str	r2, [r3, #12]
 289:../src/stm32f10x_adc.c ****   /* Initialize the ADC_NbrOfChannel member */
 290:../src/stm32f10x_adc.c ****   ADC_InitStruct->ADC_NbrOfChannel = 1;
 255              		.loc 1 290 0
 256 0168 7B68     		ldr	r3, [r7, #4]
 257 016a 4FF00102 		mov	r2, #1
 258 016e 1A74     		strb	r2, [r3, #16]
 291:../src/stm32f10x_adc.c **** }
 259              		.loc 1 291 0
 260 0170 07F10C07 		add	r7, r7, #12
 261 0174 BD46     		mov	sp, r7
 262 0176 80BC     		pop	{r7}
 263 0178 7047     		bx	lr
 264              		.cfi_endproc
 265              	.LFE31:
 267 017a 00BF     		.align	2
 268              		.global	ADC_Cmd
 269              		.thumb
 270              		.thumb_func
 272              	ADC_Cmd:
 273              	.LFB32:
 292:../src/stm32f10x_adc.c **** 
 293:../src/stm32f10x_adc.c **** /**
 294:../src/stm32f10x_adc.c ****   * @brief  Enables or disables the specified ADC peripheral.
 295:../src/stm32f10x_adc.c ****   * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
 296:../src/stm32f10x_adc.c ****   * @param  NewState: new state of the ADCx peripheral.
 297:../src/stm32f10x_adc.c ****   *   This parameter can be: ENABLE or DISABLE.
 298:../src/stm32f10x_adc.c ****   * @retval None
 299:../src/stm32f10x_adc.c ****   */
 300:../src/stm32f10x_adc.c **** void ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState)
 301:../src/stm32f10x_adc.c **** {
 274              		.loc 1 301 0
 275              		.cfi_startproc
 276              		@ args = 0, pretend = 0, frame = 8
 277              		@ frame_needed = 1, uses_anonymous_args = 0
 278              		@ link register save eliminated.
 279 017c 80B4     		push	{r7}
 280              	.LCFI9:
 281              		.cfi_def_cfa_offset 4
 282              		.cfi_offset 7, -4
 283 017e 83B0     		sub	sp, sp, #12
 284              	.LCFI10:
 285              		.cfi_def_cfa_offset 16
 286 0180 00AF     		add	r7, sp, #0
 287              	.LCFI11:
 288              		.cfi_def_cfa_register 7
 289 0182 7860     		str	r0, [r7, #4]
 290 0184 0B46     		mov	r3, r1
 291 0186 FB70     		strb	r3, [r7, #3]
 302:../src/stm32f10x_adc.c ****   /* Check the parameters */
 303:../src/stm32f10x_adc.c ****   assert_param(IS_ADC_ALL_PERIPH(ADCx));
 304:../src/stm32f10x_adc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 305:../src/stm32f10x_adc.c ****   if (NewState != DISABLE)
 292              		.loc 1 305 0
 293 0188 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 294 018a 002B     		cmp	r3, #0
 295 018c 06D0     		beq	.L8
 306:../src/stm32f10x_adc.c ****   {
 307:../src/stm32f10x_adc.c ****     /* Set the ADON bit to wake up the ADC from power down mode */
 308:../src/stm32f10x_adc.c ****     ADCx->CR2 |= CR2_ADON_Set;
 296              		.loc 1 308 0
 297 018e 7B68     		ldr	r3, [r7, #4]
 298 0190 9B68     		ldr	r3, [r3, #8]
 299 0192 43F00102 		orr	r2, r3, #1
 300 0196 7B68     		ldr	r3, [r7, #4]
 301 0198 9A60     		str	r2, [r3, #8]
 302 019a 05E0     		b	.L7
 303              	.L8:
 309:../src/stm32f10x_adc.c ****   }
 310:../src/stm32f10x_adc.c ****   else
 311:../src/stm32f10x_adc.c ****   {
 312:../src/stm32f10x_adc.c ****     /* Disable the selected ADC peripheral */
 313:../src/stm32f10x_adc.c ****     ADCx->CR2 &= CR2_ADON_Reset;
 304              		.loc 1 313 0
 305 019c 7B68     		ldr	r3, [r7, #4]
 306 019e 9B68     		ldr	r3, [r3, #8]
 307 01a0 23F00102 		bic	r2, r3, #1
 308 01a4 7B68     		ldr	r3, [r7, #4]
 309 01a6 9A60     		str	r2, [r3, #8]
 310              	.L7:
 314:../src/stm32f10x_adc.c ****   }
 315:../src/stm32f10x_adc.c **** }
 311              		.loc 1 315 0
 312 01a8 07F10C07 		add	r7, r7, #12
 313 01ac BD46     		mov	sp, r7
 314 01ae 80BC     		pop	{r7}
 315 01b0 7047     		bx	lr
 316              		.cfi_endproc
 317              	.LFE32:
 319 01b2 00BF     		.align	2
 320              		.global	ADC_DMACmd
 321              		.thumb
 322              		.thumb_func
 324              	ADC_DMACmd:
 325              	.LFB33:
 316:../src/stm32f10x_adc.c **** 
 317:../src/stm32f10x_adc.c **** /**
 318:../src/stm32f10x_adc.c ****   * @brief  Enables or disables the specified ADC DMA request.
 319:../src/stm32f10x_adc.c ****   * @param  ADCx: where x can be 1 or 3 to select the ADC peripheral.
 320:../src/stm32f10x_adc.c ****   *   Note: ADC2 hasn't a DMA capability.
 321:../src/stm32f10x_adc.c ****   * @param  NewState: new state of the selected ADC DMA transfer.
 322:../src/stm32f10x_adc.c ****   *   This parameter can be: ENABLE or DISABLE.
 323:../src/stm32f10x_adc.c ****   * @retval None
 324:../src/stm32f10x_adc.c ****   */
 325:../src/stm32f10x_adc.c **** void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState)
 326:../src/stm32f10x_adc.c **** {
 326              		.loc 1 326 0
 327              		.cfi_startproc
 328              		@ args = 0, pretend = 0, frame = 8
 329              		@ frame_needed = 1, uses_anonymous_args = 0
 330              		@ link register save eliminated.
 331 01b4 80B4     		push	{r7}
 332              	.LCFI12:
 333              		.cfi_def_cfa_offset 4
 334              		.cfi_offset 7, -4
 335 01b6 83B0     		sub	sp, sp, #12
 336              	.LCFI13:
 337              		.cfi_def_cfa_offset 16
 338 01b8 00AF     		add	r7, sp, #0
 339              	.LCFI14:
 340              		.cfi_def_cfa_register 7
 341 01ba 7860     		str	r0, [r7, #4]
 342 01bc 0B46     		mov	r3, r1
 343 01be FB70     		strb	r3, [r7, #3]
 327:../src/stm32f10x_adc.c ****   /* Check the parameters */
 328:../src/stm32f10x_adc.c ****   assert_param(IS_ADC_DMA_PERIPH(ADCx));
 329:../src/stm32f10x_adc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 330:../src/stm32f10x_adc.c ****   if (NewState != DISABLE)
 344              		.loc 1 330 0
 345 01c0 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 346 01c2 002B     		cmp	r3, #0
 347 01c4 06D0     		beq	.L11
 331:../src/stm32f10x_adc.c ****   {
 332:../src/stm32f10x_adc.c ****     /* Enable the selected ADC DMA request */
 333:../src/stm32f10x_adc.c ****     ADCx->CR2 |= CR2_DMA_Set;
 348              		.loc 1 333 0
 349 01c6 7B68     		ldr	r3, [r7, #4]
 350 01c8 9B68     		ldr	r3, [r3, #8]
 351 01ca 43F48072 		orr	r2, r3, #256
 352 01ce 7B68     		ldr	r3, [r7, #4]
 353 01d0 9A60     		str	r2, [r3, #8]
 354 01d2 05E0     		b	.L10
 355              	.L11:
 334:../src/stm32f10x_adc.c ****   }
 335:../src/stm32f10x_adc.c ****   else
 336:../src/stm32f10x_adc.c ****   {
 337:../src/stm32f10x_adc.c ****     /* Disable the selected ADC DMA request */
 338:../src/stm32f10x_adc.c ****     ADCx->CR2 &= CR2_DMA_Reset;
 356              		.loc 1 338 0
 357 01d4 7B68     		ldr	r3, [r7, #4]
 358 01d6 9B68     		ldr	r3, [r3, #8]
 359 01d8 23F48072 		bic	r2, r3, #256
 360 01dc 7B68     		ldr	r3, [r7, #4]
 361 01de 9A60     		str	r2, [r3, #8]
 362              	.L10:
 339:../src/stm32f10x_adc.c ****   }
 340:../src/stm32f10x_adc.c **** }
 363              		.loc 1 340 0
 364 01e0 07F10C07 		add	r7, r7, #12
 365 01e4 BD46     		mov	sp, r7
 366 01e6 80BC     		pop	{r7}
 367 01e8 7047     		bx	lr
 368              		.cfi_endproc
 369              	.LFE33:
 371 01ea 00BF     		.align	2
 372              		.global	ADC_ITConfig
 373              		.thumb
 374              		.thumb_func
 376              	ADC_ITConfig:
 377              	.LFB34:
 341:../src/stm32f10x_adc.c **** 
 342:../src/stm32f10x_adc.c **** /**
 343:../src/stm32f10x_adc.c ****   * @brief  Enables or disables the specified ADC interrupts.
 344:../src/stm32f10x_adc.c ****   * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
 345:../src/stm32f10x_adc.c ****   * @param  ADC_IT: specifies the ADC interrupt sources to be enabled or disabled. 
 346:../src/stm32f10x_adc.c ****   *   This parameter can be any combination of the following values:
 347:../src/stm32f10x_adc.c ****   *     @arg ADC_IT_EOC: End of conversion interrupt mask
 348:../src/stm32f10x_adc.c ****   *     @arg ADC_IT_AWD: Analog watchdog interrupt mask
 349:../src/stm32f10x_adc.c ****   *     @arg ADC_IT_JEOC: End of injected conversion interrupt mask
 350:../src/stm32f10x_adc.c ****   * @param  NewState: new state of the specified ADC interrupts.
 351:../src/stm32f10x_adc.c ****   *   This parameter can be: ENABLE or DISABLE.
 352:../src/stm32f10x_adc.c ****   * @retval None
 353:../src/stm32f10x_adc.c ****   */
 354:../src/stm32f10x_adc.c **** void ADC_ITConfig(ADC_TypeDef* ADCx, uint16_t ADC_IT, FunctionalState NewState)
 355:../src/stm32f10x_adc.c **** {
 378              		.loc 1 355 0
 379              		.cfi_startproc
 380              		@ args = 0, pretend = 0, frame = 16
 381              		@ frame_needed = 1, uses_anonymous_args = 0
 382              		@ link register save eliminated.
 383 01ec 80B4     		push	{r7}
 384              	.LCFI15:
 385              		.cfi_def_cfa_offset 4
 386              		.cfi_offset 7, -4
 387 01ee 85B0     		sub	sp, sp, #20
 388              	.LCFI16:
 389              		.cfi_def_cfa_offset 24
 390 01f0 00AF     		add	r7, sp, #0
 391              	.LCFI17:
 392              		.cfi_def_cfa_register 7
 393 01f2 7860     		str	r0, [r7, #4]
 394 01f4 1346     		mov	r3, r2
 395 01f6 0A46     		mov	r2, r1	@ movhi
 396 01f8 7A80     		strh	r2, [r7, #2]	@ movhi
 397 01fa 7B70     		strb	r3, [r7, #1]
 356:../src/stm32f10x_adc.c ****   uint8_t itmask = 0;
 398              		.loc 1 356 0
 399 01fc 4FF00003 		mov	r3, #0
 400 0200 FB73     		strb	r3, [r7, #15]
 357:../src/stm32f10x_adc.c ****   /* Check the parameters */
 358:../src/stm32f10x_adc.c ****   assert_param(IS_ADC_ALL_PERIPH(ADCx));
 359:../src/stm32f10x_adc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 360:../src/stm32f10x_adc.c ****   assert_param(IS_ADC_IT(ADC_IT));
 361:../src/stm32f10x_adc.c ****   /* Get the ADC IT index */
 362:../src/stm32f10x_adc.c ****   itmask = (uint8_t)ADC_IT;
 401              		.loc 1 362 0
 402 0202 7B88     		ldrh	r3, [r7, #2]	@ movhi
 403 0204 FB73     		strb	r3, [r7, #15]
 363:../src/stm32f10x_adc.c ****   if (NewState != DISABLE)
 404              		.loc 1 363 0
 405 0206 7B78     		ldrb	r3, [r7, #1]	@ zero_extendqisi2
 406 0208 002B     		cmp	r3, #0
 407 020a 07D0     		beq	.L14
 364:../src/stm32f10x_adc.c ****   {
 365:../src/stm32f10x_adc.c ****     /* Enable the selected ADC interrupts */
 366:../src/stm32f10x_adc.c ****     ADCx->CR1 |= itmask;
 408              		.loc 1 366 0
 409 020c 7B68     		ldr	r3, [r7, #4]
 410 020e 5B68     		ldr	r3, [r3, #4]
 411 0210 1A46     		mov	r2, r3
 412 0212 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 413 0214 1A43     		orrs	r2, r2, r3
 414 0216 7B68     		ldr	r3, [r7, #4]
 415 0218 5A60     		str	r2, [r3, #4]
 416 021a 08E0     		b	.L13
 417              	.L14:
 367:../src/stm32f10x_adc.c ****   }
 368:../src/stm32f10x_adc.c ****   else
 369:../src/stm32f10x_adc.c ****   {
 370:../src/stm32f10x_adc.c ****     /* Disable the selected ADC interrupts */
 371:../src/stm32f10x_adc.c ****     ADCx->CR1 &= (~(uint32_t)itmask);
 418              		.loc 1 371 0
 419 021c 7B68     		ldr	r3, [r7, #4]
 420 021e 5B68     		ldr	r3, [r3, #4]
 421 0220 1A46     		mov	r2, r3
 422 0222 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 423 0224 6FEA0303 		mvn	r3, r3
 424 0228 1A40     		ands	r2, r2, r3
 425 022a 7B68     		ldr	r3, [r7, #4]
 426 022c 5A60     		str	r2, [r3, #4]
 427              	.L13:
 372:../src/stm32f10x_adc.c ****   }
 373:../src/stm32f10x_adc.c **** }
 428              		.loc 1 373 0
 429 022e 07F11407 		add	r7, r7, #20
 430 0232 BD46     		mov	sp, r7
 431 0234 80BC     		pop	{r7}
 432 0236 7047     		bx	lr
 433              		.cfi_endproc
 434              	.LFE34:
 436              		.align	2
 437              		.global	ADC_ResetCalibration
 438              		.thumb
 439              		.thumb_func
 441              	ADC_ResetCalibration:
 442              	.LFB35:
 374:../src/stm32f10x_adc.c **** 
 375:../src/stm32f10x_adc.c **** /**
 376:../src/stm32f10x_adc.c ****   * @brief  Resets the selected ADC calibration registers.
 377:../src/stm32f10x_adc.c ****   * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
 378:../src/stm32f10x_adc.c ****   * @retval None
 379:../src/stm32f10x_adc.c ****   */
 380:../src/stm32f10x_adc.c **** void ADC_ResetCalibration(ADC_TypeDef* ADCx)
 381:../src/stm32f10x_adc.c **** {
 443              		.loc 1 381 0
 444              		.cfi_startproc
 445              		@ args = 0, pretend = 0, frame = 8
 446              		@ frame_needed = 1, uses_anonymous_args = 0
 447              		@ link register save eliminated.
 448 0238 80B4     		push	{r7}
 449              	.LCFI18:
 450              		.cfi_def_cfa_offset 4
 451              		.cfi_offset 7, -4
 452 023a 83B0     		sub	sp, sp, #12
 453              	.LCFI19:
 454              		.cfi_def_cfa_offset 16
 455 023c 00AF     		add	r7, sp, #0
 456              	.LCFI20:
 457              		.cfi_def_cfa_register 7
 458 023e 7860     		str	r0, [r7, #4]
 382:../src/stm32f10x_adc.c ****   /* Check the parameters */
 383:../src/stm32f10x_adc.c ****   assert_param(IS_ADC_ALL_PERIPH(ADCx));
 384:../src/stm32f10x_adc.c ****   /* Resets the selected ADC calibration registers */  
 385:../src/stm32f10x_adc.c ****   ADCx->CR2 |= CR2_RSTCAL_Set;
 459              		.loc 1 385 0
 460 0240 7B68     		ldr	r3, [r7, #4]
 461 0242 9B68     		ldr	r3, [r3, #8]
 462 0244 43F00802 		orr	r2, r3, #8
 463 0248 7B68     		ldr	r3, [r7, #4]
 464 024a 9A60     		str	r2, [r3, #8]
 386:../src/stm32f10x_adc.c **** }
 465              		.loc 1 386 0
 466 024c 07F10C07 		add	r7, r7, #12
 467 0250 BD46     		mov	sp, r7
 468 0252 80BC     		pop	{r7}
 469 0254 7047     		bx	lr
 470              		.cfi_endproc
 471              	.LFE35:
 473 0256 00BF     		.align	2
 474              		.global	ADC_GetResetCalibrationStatus
 475              		.thumb
 476              		.thumb_func
 478              	ADC_GetResetCalibrationStatus:
 479              	.LFB36:
 387:../src/stm32f10x_adc.c **** 
 388:../src/stm32f10x_adc.c **** /**
 389:../src/stm32f10x_adc.c ****   * @brief  Gets the selected ADC reset calibration registers status.
 390:../src/stm32f10x_adc.c ****   * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
 391:../src/stm32f10x_adc.c ****   * @retval The new state of ADC reset calibration registers (SET or RESET).
 392:../src/stm32f10x_adc.c ****   */
 393:../src/stm32f10x_adc.c **** FlagStatus ADC_GetResetCalibrationStatus(ADC_TypeDef* ADCx)
 394:../src/stm32f10x_adc.c **** {
 480              		.loc 1 394 0
 481              		.cfi_startproc
 482              		@ args = 0, pretend = 0, frame = 16
 483              		@ frame_needed = 1, uses_anonymous_args = 0
 484              		@ link register save eliminated.
 485 0258 80B4     		push	{r7}
 486              	.LCFI21:
 487              		.cfi_def_cfa_offset 4
 488              		.cfi_offset 7, -4
 489 025a 85B0     		sub	sp, sp, #20
 490              	.LCFI22:
 491              		.cfi_def_cfa_offset 24
 492 025c 00AF     		add	r7, sp, #0
 493              	.LCFI23:
 494              		.cfi_def_cfa_register 7
 495 025e 7860     		str	r0, [r7, #4]
 395:../src/stm32f10x_adc.c ****   FlagStatus bitstatus = RESET;
 496              		.loc 1 395 0
 497 0260 4FF00003 		mov	r3, #0
 498 0264 FB73     		strb	r3, [r7, #15]
 396:../src/stm32f10x_adc.c ****   /* Check the parameters */
 397:../src/stm32f10x_adc.c ****   assert_param(IS_ADC_ALL_PERIPH(ADCx));
 398:../src/stm32f10x_adc.c ****   /* Check the status of RSTCAL bit */
 399:../src/stm32f10x_adc.c ****   if ((ADCx->CR2 & CR2_RSTCAL_Set) != (uint32_t)RESET)
 499              		.loc 1 399 0
 500 0266 7B68     		ldr	r3, [r7, #4]
 501 0268 9B68     		ldr	r3, [r3, #8]
 502 026a 03F00803 		and	r3, r3, #8
 503 026e 002B     		cmp	r3, #0
 504 0270 03D0     		beq	.L18
 400:../src/stm32f10x_adc.c ****   {
 401:../src/stm32f10x_adc.c ****     /* RSTCAL bit is set */
 402:../src/stm32f10x_adc.c ****     bitstatus = SET;
 505              		.loc 1 402 0
 506 0272 4FF00103 		mov	r3, #1
 507 0276 FB73     		strb	r3, [r7, #15]
 508 0278 02E0     		b	.L19
 509              	.L18:
 403:../src/stm32f10x_adc.c ****   }
 404:../src/stm32f10x_adc.c ****   else
 405:../src/stm32f10x_adc.c ****   {
 406:../src/stm32f10x_adc.c ****     /* RSTCAL bit is reset */
 407:../src/stm32f10x_adc.c ****     bitstatus = RESET;
 510              		.loc 1 407 0
 511 027a 4FF00003 		mov	r3, #0
 512 027e FB73     		strb	r3, [r7, #15]
 513              	.L19:
 408:../src/stm32f10x_adc.c ****   }
 409:../src/stm32f10x_adc.c ****   /* Return the RSTCAL bit status */
 410:../src/stm32f10x_adc.c ****   return  bitstatus;
 514              		.loc 1 410 0
 515 0280 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 411:../src/stm32f10x_adc.c **** }
 516              		.loc 1 411 0
 517 0282 1846     		mov	r0, r3
 518 0284 07F11407 		add	r7, r7, #20
 519 0288 BD46     		mov	sp, r7
 520 028a 80BC     		pop	{r7}
 521 028c 7047     		bx	lr
 522              		.cfi_endproc
 523              	.LFE36:
 525 028e 00BF     		.align	2
 526              		.global	ADC_StartCalibration
 527              		.thumb
 528              		.thumb_func
 530              	ADC_StartCalibration:
 531              	.LFB37:
 412:../src/stm32f10x_adc.c **** 
 413:../src/stm32f10x_adc.c **** /**
 414:../src/stm32f10x_adc.c ****   * @brief  Starts the selected ADC calibration process.
 415:../src/stm32f10x_adc.c ****   * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
 416:../src/stm32f10x_adc.c ****   * @retval None
 417:../src/stm32f10x_adc.c ****   */
 418:../src/stm32f10x_adc.c **** void ADC_StartCalibration(ADC_TypeDef* ADCx)
 419:../src/stm32f10x_adc.c **** {
 532              		.loc 1 419 0
 533              		.cfi_startproc
 534              		@ args = 0, pretend = 0, frame = 8
 535              		@ frame_needed = 1, uses_anonymous_args = 0
 536              		@ link register save eliminated.
 537 0290 80B4     		push	{r7}
 538              	.LCFI24:
 539              		.cfi_def_cfa_offset 4
 540              		.cfi_offset 7, -4
 541 0292 83B0     		sub	sp, sp, #12
 542              	.LCFI25:
 543              		.cfi_def_cfa_offset 16
 544 0294 00AF     		add	r7, sp, #0
 545              	.LCFI26:
 546              		.cfi_def_cfa_register 7
 547 0296 7860     		str	r0, [r7, #4]
 420:../src/stm32f10x_adc.c ****   /* Check the parameters */
 421:../src/stm32f10x_adc.c ****   assert_param(IS_ADC_ALL_PERIPH(ADCx));
 422:../src/stm32f10x_adc.c ****   /* Enable the selected ADC calibration process */  
 423:../src/stm32f10x_adc.c ****   ADCx->CR2 |= CR2_CAL_Set;
 548              		.loc 1 423 0
 549 0298 7B68     		ldr	r3, [r7, #4]
 550 029a 9B68     		ldr	r3, [r3, #8]
 551 029c 43F00402 		orr	r2, r3, #4
 552 02a0 7B68     		ldr	r3, [r7, #4]
 553 02a2 9A60     		str	r2, [r3, #8]
 424:../src/stm32f10x_adc.c **** }
 554              		.loc 1 424 0
 555 02a4 07F10C07 		add	r7, r7, #12
 556 02a8 BD46     		mov	sp, r7
 557 02aa 80BC     		pop	{r7}
 558 02ac 7047     		bx	lr
 559              		.cfi_endproc
 560              	.LFE37:
 562 02ae 00BF     		.align	2
 563              		.global	ADC_GetCalibrationStatus
 564              		.thumb
 565              		.thumb_func
 567              	ADC_GetCalibrationStatus:
 568              	.LFB38:
 425:../src/stm32f10x_adc.c **** 
 426:../src/stm32f10x_adc.c **** /**
 427:../src/stm32f10x_adc.c ****   * @brief  Gets the selected ADC calibration status.
 428:../src/stm32f10x_adc.c ****   * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
 429:../src/stm32f10x_adc.c ****   * @retval The new state of ADC calibration (SET or RESET).
 430:../src/stm32f10x_adc.c ****   */
 431:../src/stm32f10x_adc.c **** FlagStatus ADC_GetCalibrationStatus(ADC_TypeDef* ADCx)
 432:../src/stm32f10x_adc.c **** {
 569              		.loc 1 432 0
 570              		.cfi_startproc
 571              		@ args = 0, pretend = 0, frame = 16
 572              		@ frame_needed = 1, uses_anonymous_args = 0
 573              		@ link register save eliminated.
 574 02b0 80B4     		push	{r7}
 575              	.LCFI27:
 576              		.cfi_def_cfa_offset 4
 577              		.cfi_offset 7, -4
 578 02b2 85B0     		sub	sp, sp, #20
 579              	.LCFI28:
 580              		.cfi_def_cfa_offset 24
 581 02b4 00AF     		add	r7, sp, #0
 582              	.LCFI29:
 583              		.cfi_def_cfa_register 7
 584 02b6 7860     		str	r0, [r7, #4]
 433:../src/stm32f10x_adc.c ****   FlagStatus bitstatus = RESET;
 585              		.loc 1 433 0
 586 02b8 4FF00003 		mov	r3, #0
 587 02bc FB73     		strb	r3, [r7, #15]
 434:../src/stm32f10x_adc.c ****   /* Check the parameters */
 435:../src/stm32f10x_adc.c ****   assert_param(IS_ADC_ALL_PERIPH(ADCx));
 436:../src/stm32f10x_adc.c ****   /* Check the status of CAL bit */
 437:../src/stm32f10x_adc.c ****   if ((ADCx->CR2 & CR2_CAL_Set) != (uint32_t)RESET)
 588              		.loc 1 437 0
 589 02be 7B68     		ldr	r3, [r7, #4]
 590 02c0 9B68     		ldr	r3, [r3, #8]
 591 02c2 03F00403 		and	r3, r3, #4
 592 02c6 002B     		cmp	r3, #0
 593 02c8 03D0     		beq	.L22
 438:../src/stm32f10x_adc.c ****   {
 439:../src/stm32f10x_adc.c ****     /* CAL bit is set: calibration on going */
 440:../src/stm32f10x_adc.c ****     bitstatus = SET;
 594              		.loc 1 440 0
 595 02ca 4FF00103 		mov	r3, #1
 596 02ce FB73     		strb	r3, [r7, #15]
 597 02d0 02E0     		b	.L23
 598              	.L22:
 441:../src/stm32f10x_adc.c ****   }
 442:../src/stm32f10x_adc.c ****   else
 443:../src/stm32f10x_adc.c ****   {
 444:../src/stm32f10x_adc.c ****     /* CAL bit is reset: end of calibration */
 445:../src/stm32f10x_adc.c ****     bitstatus = RESET;
 599              		.loc 1 445 0
 600 02d2 4FF00003 		mov	r3, #0
 601 02d6 FB73     		strb	r3, [r7, #15]
 602              	.L23:
 446:../src/stm32f10x_adc.c ****   }
 447:../src/stm32f10x_adc.c ****   /* Return the CAL bit status */
 448:../src/stm32f10x_adc.c ****   return  bitstatus;
 603              		.loc 1 448 0
 604 02d8 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 449:../src/stm32f10x_adc.c **** }
 605              		.loc 1 449 0
 606 02da 1846     		mov	r0, r3
 607 02dc 07F11407 		add	r7, r7, #20
 608 02e0 BD46     		mov	sp, r7
 609 02e2 80BC     		pop	{r7}
 610 02e4 7047     		bx	lr
 611              		.cfi_endproc
 612              	.LFE38:
 614 02e6 00BF     		.align	2
 615              		.global	ADC_SoftwareStartConvCmd
 616              		.thumb
 617              		.thumb_func
 619              	ADC_SoftwareStartConvCmd:
 620              	.LFB39:
 450:../src/stm32f10x_adc.c **** 
 451:../src/stm32f10x_adc.c **** /**
 452:../src/stm32f10x_adc.c ****   * @brief  Enables or disables the selected ADC software start conversion .
 453:../src/stm32f10x_adc.c ****   * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
 454:../src/stm32f10x_adc.c ****   * @param  NewState: new state of the selected ADC software start conversion.
 455:../src/stm32f10x_adc.c ****   *   This parameter can be: ENABLE or DISABLE.
 456:../src/stm32f10x_adc.c ****   * @retval None
 457:../src/stm32f10x_adc.c ****   */
 458:../src/stm32f10x_adc.c **** void ADC_SoftwareStartConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
 459:../src/stm32f10x_adc.c **** {
 621              		.loc 1 459 0
 622              		.cfi_startproc
 623              		@ args = 0, pretend = 0, frame = 8
 624              		@ frame_needed = 1, uses_anonymous_args = 0
 625              		@ link register save eliminated.
 626 02e8 80B4     		push	{r7}
 627              	.LCFI30:
 628              		.cfi_def_cfa_offset 4
 629              		.cfi_offset 7, -4
 630 02ea 83B0     		sub	sp, sp, #12
 631              	.LCFI31:
 632              		.cfi_def_cfa_offset 16
 633 02ec 00AF     		add	r7, sp, #0
 634              	.LCFI32:
 635              		.cfi_def_cfa_register 7
 636 02ee 7860     		str	r0, [r7, #4]
 637 02f0 0B46     		mov	r3, r1
 638 02f2 FB70     		strb	r3, [r7, #3]
 460:../src/stm32f10x_adc.c ****   /* Check the parameters */
 461:../src/stm32f10x_adc.c ****   assert_param(IS_ADC_ALL_PERIPH(ADCx));
 462:../src/stm32f10x_adc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 463:../src/stm32f10x_adc.c ****   if (NewState != DISABLE)
 639              		.loc 1 463 0
 640 02f4 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 641 02f6 002B     		cmp	r3, #0
 642 02f8 06D0     		beq	.L25
 464:../src/stm32f10x_adc.c ****   {
 465:../src/stm32f10x_adc.c ****     /* Enable the selected ADC conversion on external event and start the selected
 466:../src/stm32f10x_adc.c ****        ADC conversion */
 467:../src/stm32f10x_adc.c ****     ADCx->CR2 |= CR2_EXTTRIG_SWSTART_Set;
 643              		.loc 1 467 0
 644 02fa 7B68     		ldr	r3, [r7, #4]
 645 02fc 9B68     		ldr	r3, [r3, #8]
 646 02fe 43F4A002 		orr	r2, r3, #5242880
 647 0302 7B68     		ldr	r3, [r7, #4]
 648 0304 9A60     		str	r2, [r3, #8]
 649 0306 05E0     		b	.L24
 650              	.L25:
 468:../src/stm32f10x_adc.c ****   }
 469:../src/stm32f10x_adc.c ****   else
 470:../src/stm32f10x_adc.c ****   {
 471:../src/stm32f10x_adc.c ****     /* Disable the selected ADC conversion on external event and stop the selected
 472:../src/stm32f10x_adc.c ****        ADC conversion */
 473:../src/stm32f10x_adc.c ****     ADCx->CR2 &= CR2_EXTTRIG_SWSTART_Reset;
 651              		.loc 1 473 0
 652 0308 7B68     		ldr	r3, [r7, #4]
 653 030a 9B68     		ldr	r3, [r3, #8]
 654 030c 23F4A002 		bic	r2, r3, #5242880
 655 0310 7B68     		ldr	r3, [r7, #4]
 656 0312 9A60     		str	r2, [r3, #8]
 657              	.L24:
 474:../src/stm32f10x_adc.c ****   }
 475:../src/stm32f10x_adc.c **** }
 658              		.loc 1 475 0
 659 0314 07F10C07 		add	r7, r7, #12
 660 0318 BD46     		mov	sp, r7
 661 031a 80BC     		pop	{r7}
 662 031c 7047     		bx	lr
 663              		.cfi_endproc
 664              	.LFE39:
 666 031e 00BF     		.align	2
 667              		.global	ADC_GetSoftwareStartConvStatus
 668              		.thumb
 669              		.thumb_func
 671              	ADC_GetSoftwareStartConvStatus:
 672              	.LFB40:
 476:../src/stm32f10x_adc.c **** 
 477:../src/stm32f10x_adc.c **** /**
 478:../src/stm32f10x_adc.c ****   * @brief  Gets the selected ADC Software start conversion Status.
 479:../src/stm32f10x_adc.c ****   * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
 480:../src/stm32f10x_adc.c ****   * @retval The new state of ADC software start conversion (SET or RESET).
 481:../src/stm32f10x_adc.c ****   */
 482:../src/stm32f10x_adc.c **** FlagStatus ADC_GetSoftwareStartConvStatus(ADC_TypeDef* ADCx)
 483:../src/stm32f10x_adc.c **** {
 673              		.loc 1 483 0
 674              		.cfi_startproc
 675              		@ args = 0, pretend = 0, frame = 16
 676              		@ frame_needed = 1, uses_anonymous_args = 0
 677              		@ link register save eliminated.
 678 0320 80B4     		push	{r7}
 679              	.LCFI33:
 680              		.cfi_def_cfa_offset 4
 681              		.cfi_offset 7, -4
 682 0322 85B0     		sub	sp, sp, #20
 683              	.LCFI34:
 684              		.cfi_def_cfa_offset 24
 685 0324 00AF     		add	r7, sp, #0
 686              	.LCFI35:
 687              		.cfi_def_cfa_register 7
 688 0326 7860     		str	r0, [r7, #4]
 484:../src/stm32f10x_adc.c ****   FlagStatus bitstatus = RESET;
 689              		.loc 1 484 0
 690 0328 4FF00003 		mov	r3, #0
 691 032c FB73     		strb	r3, [r7, #15]
 485:../src/stm32f10x_adc.c ****   /* Check the parameters */
 486:../src/stm32f10x_adc.c ****   assert_param(IS_ADC_ALL_PERIPH(ADCx));
 487:../src/stm32f10x_adc.c ****   /* Check the status of SWSTART bit */
 488:../src/stm32f10x_adc.c ****   if ((ADCx->CR2 & CR2_SWSTART_Set) != (uint32_t)RESET)
 692              		.loc 1 488 0
 693 032e 7B68     		ldr	r3, [r7, #4]
 694 0330 9B68     		ldr	r3, [r3, #8]
 695 0332 03F48003 		and	r3, r3, #4194304
 696 0336 002B     		cmp	r3, #0
 697 0338 03D0     		beq	.L28
 489:../src/stm32f10x_adc.c ****   {
 490:../src/stm32f10x_adc.c ****     /* SWSTART bit is set */
 491:../src/stm32f10x_adc.c ****     bitstatus = SET;
 698              		.loc 1 491 0
 699 033a 4FF00103 		mov	r3, #1
 700 033e FB73     		strb	r3, [r7, #15]
 701 0340 02E0     		b	.L29
 702              	.L28:
 492:../src/stm32f10x_adc.c ****   }
 493:../src/stm32f10x_adc.c ****   else
 494:../src/stm32f10x_adc.c ****   {
 495:../src/stm32f10x_adc.c ****     /* SWSTART bit is reset */
 496:../src/stm32f10x_adc.c ****     bitstatus = RESET;
 703              		.loc 1 496 0
 704 0342 4FF00003 		mov	r3, #0
 705 0346 FB73     		strb	r3, [r7, #15]
 706              	.L29:
 497:../src/stm32f10x_adc.c ****   }
 498:../src/stm32f10x_adc.c ****   /* Return the SWSTART bit status */
 499:../src/stm32f10x_adc.c ****   return  bitstatus;
 707              		.loc 1 499 0
 708 0348 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 500:../src/stm32f10x_adc.c **** }
 709              		.loc 1 500 0
 710 034a 1846     		mov	r0, r3
 711 034c 07F11407 		add	r7, r7, #20
 712 0350 BD46     		mov	sp, r7
 713 0352 80BC     		pop	{r7}
 714 0354 7047     		bx	lr
 715              		.cfi_endproc
 716              	.LFE40:
 718 0356 00BF     		.align	2
 719              		.global	ADC_DiscModeChannelCountConfig
 720              		.thumb
 721              		.thumb_func
 723              	ADC_DiscModeChannelCountConfig:
 724              	.LFB41:
 501:../src/stm32f10x_adc.c **** 
 502:../src/stm32f10x_adc.c **** /**
 503:../src/stm32f10x_adc.c ****   * @brief  Configures the discontinuous mode for the selected ADC regular
 504:../src/stm32f10x_adc.c ****   *         group channel.
 505:../src/stm32f10x_adc.c ****   * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
 506:../src/stm32f10x_adc.c ****   * @param  Number: specifies the discontinuous mode regular channel
 507:../src/stm32f10x_adc.c ****   *         count value. This number must be between 1 and 8.
 508:../src/stm32f10x_adc.c ****   * @retval None
 509:../src/stm32f10x_adc.c ****   */
 510:../src/stm32f10x_adc.c **** void ADC_DiscModeChannelCountConfig(ADC_TypeDef* ADCx, uint8_t Number)
 511:../src/stm32f10x_adc.c **** {
 725              		.loc 1 511 0
 726              		.cfi_startproc
 727              		@ args = 0, pretend = 0, frame = 16
 728              		@ frame_needed = 1, uses_anonymous_args = 0
 729              		@ link register save eliminated.
 730 0358 80B4     		push	{r7}
 731              	.LCFI36:
 732              		.cfi_def_cfa_offset 4
 733              		.cfi_offset 7, -4
 734 035a 85B0     		sub	sp, sp, #20
 735              	.LCFI37:
 736              		.cfi_def_cfa_offset 24
 737 035c 00AF     		add	r7, sp, #0
 738              	.LCFI38:
 739              		.cfi_def_cfa_register 7
 740 035e 7860     		str	r0, [r7, #4]
 741 0360 0B46     		mov	r3, r1
 742 0362 FB70     		strb	r3, [r7, #3]
 512:../src/stm32f10x_adc.c ****   uint32_t tmpreg1 = 0;
 743              		.loc 1 512 0
 744 0364 4FF00003 		mov	r3, #0
 745 0368 FB60     		str	r3, [r7, #12]
 513:../src/stm32f10x_adc.c ****   uint32_t tmpreg2 = 0;
 746              		.loc 1 513 0
 747 036a 4FF00003 		mov	r3, #0
 748 036e BB60     		str	r3, [r7, #8]
 514:../src/stm32f10x_adc.c ****   /* Check the parameters */
 515:../src/stm32f10x_adc.c ****   assert_param(IS_ADC_ALL_PERIPH(ADCx));
 516:../src/stm32f10x_adc.c ****   assert_param(IS_ADC_REGULAR_DISC_NUMBER(Number));
 517:../src/stm32f10x_adc.c ****   /* Get the old register value */
 518:../src/stm32f10x_adc.c ****   tmpreg1 = ADCx->CR1;
 749              		.loc 1 518 0
 750 0370 7B68     		ldr	r3, [r7, #4]
 751 0372 5B68     		ldr	r3, [r3, #4]
 752 0374 FB60     		str	r3, [r7, #12]
 519:../src/stm32f10x_adc.c ****   /* Clear the old discontinuous mode channel count */
 520:../src/stm32f10x_adc.c ****   tmpreg1 &= CR1_DISCNUM_Reset;
 753              		.loc 1 520 0
 754 0376 FB68     		ldr	r3, [r7, #12]
 755 0378 23F46043 		bic	r3, r3, #57344
 756 037c FB60     		str	r3, [r7, #12]
 521:../src/stm32f10x_adc.c ****   /* Set the discontinuous mode channel count */
 522:../src/stm32f10x_adc.c ****   tmpreg2 = Number - 1;
 757              		.loc 1 522 0
 758 037e FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 759 0380 03F1FF33 		add	r3, r3, #-1
 760 0384 BB60     		str	r3, [r7, #8]
 523:../src/stm32f10x_adc.c ****   tmpreg1 |= tmpreg2 << 13;
 761              		.loc 1 523 0
 762 0386 BB68     		ldr	r3, [r7, #8]
 763 0388 4FEA4333 		lsl	r3, r3, #13
 764 038c FA68     		ldr	r2, [r7, #12]
 765 038e 1343     		orrs	r3, r3, r2
 766 0390 FB60     		str	r3, [r7, #12]
 524:../src/stm32f10x_adc.c ****   /* Store the new register value */
 525:../src/stm32f10x_adc.c ****   ADCx->CR1 = tmpreg1;
 767              		.loc 1 525 0
 768 0392 7B68     		ldr	r3, [r7, #4]
 769 0394 FA68     		ldr	r2, [r7, #12]
 770 0396 5A60     		str	r2, [r3, #4]
 526:../src/stm32f10x_adc.c **** }
 771              		.loc 1 526 0
 772 0398 07F11407 		add	r7, r7, #20
 773 039c BD46     		mov	sp, r7
 774 039e 80BC     		pop	{r7}
 775 03a0 7047     		bx	lr
 776              		.cfi_endproc
 777              	.LFE41:
 779 03a2 00BF     		.align	2
 780              		.global	ADC_DiscModeCmd
 781              		.thumb
 782              		.thumb_func
 784              	ADC_DiscModeCmd:
 785              	.LFB42:
 527:../src/stm32f10x_adc.c **** 
 528:../src/stm32f10x_adc.c **** /**
 529:../src/stm32f10x_adc.c ****   * @brief  Enables or disables the discontinuous mode on regular group
 530:../src/stm32f10x_adc.c ****   *         channel for the specified ADC
 531:../src/stm32f10x_adc.c ****   * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
 532:../src/stm32f10x_adc.c ****   * @param  NewState: new state of the selected ADC discontinuous mode
 533:../src/stm32f10x_adc.c ****   *         on regular group channel.
 534:../src/stm32f10x_adc.c ****   *         This parameter can be: ENABLE or DISABLE.
 535:../src/stm32f10x_adc.c ****   * @retval None
 536:../src/stm32f10x_adc.c ****   */
 537:../src/stm32f10x_adc.c **** void ADC_DiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
 538:../src/stm32f10x_adc.c **** {
 786              		.loc 1 538 0
 787              		.cfi_startproc
 788              		@ args = 0, pretend = 0, frame = 8
 789              		@ frame_needed = 1, uses_anonymous_args = 0
 790              		@ link register save eliminated.
 791 03a4 80B4     		push	{r7}
 792              	.LCFI39:
 793              		.cfi_def_cfa_offset 4
 794              		.cfi_offset 7, -4
 795 03a6 83B0     		sub	sp, sp, #12
 796              	.LCFI40:
 797              		.cfi_def_cfa_offset 16
 798 03a8 00AF     		add	r7, sp, #0
 799              	.LCFI41:
 800              		.cfi_def_cfa_register 7
 801 03aa 7860     		str	r0, [r7, #4]
 802 03ac 0B46     		mov	r3, r1
 803 03ae FB70     		strb	r3, [r7, #3]
 539:../src/stm32f10x_adc.c ****   /* Check the parameters */
 540:../src/stm32f10x_adc.c ****   assert_param(IS_ADC_ALL_PERIPH(ADCx));
 541:../src/stm32f10x_adc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 542:../src/stm32f10x_adc.c ****   if (NewState != DISABLE)
 804              		.loc 1 542 0
 805 03b0 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 806 03b2 002B     		cmp	r3, #0
 807 03b4 06D0     		beq	.L32
 543:../src/stm32f10x_adc.c ****   {
 544:../src/stm32f10x_adc.c ****     /* Enable the selected ADC regular discontinuous mode */
 545:../src/stm32f10x_adc.c ****     ADCx->CR1 |= CR1_DISCEN_Set;
 808              		.loc 1 545 0
 809 03b6 7B68     		ldr	r3, [r7, #4]
 810 03b8 5B68     		ldr	r3, [r3, #4]
 811 03ba 43F40062 		orr	r2, r3, #2048
 812 03be 7B68     		ldr	r3, [r7, #4]
 813 03c0 5A60     		str	r2, [r3, #4]
 814 03c2 05E0     		b	.L31
 815              	.L32:
 546:../src/stm32f10x_adc.c ****   }
 547:../src/stm32f10x_adc.c ****   else
 548:../src/stm32f10x_adc.c ****   {
 549:../src/stm32f10x_adc.c ****     /* Disable the selected ADC regular discontinuous mode */
 550:../src/stm32f10x_adc.c ****     ADCx->CR1 &= CR1_DISCEN_Reset;
 816              		.loc 1 550 0
 817 03c4 7B68     		ldr	r3, [r7, #4]
 818 03c6 5B68     		ldr	r3, [r3, #4]
 819 03c8 23F40062 		bic	r2, r3, #2048
 820 03cc 7B68     		ldr	r3, [r7, #4]
 821 03ce 5A60     		str	r2, [r3, #4]
 822              	.L31:
 551:../src/stm32f10x_adc.c ****   }
 552:../src/stm32f10x_adc.c **** }
 823              		.loc 1 552 0
 824 03d0 07F10C07 		add	r7, r7, #12
 825 03d4 BD46     		mov	sp, r7
 826 03d6 80BC     		pop	{r7}
 827 03d8 7047     		bx	lr
 828              		.cfi_endproc
 829              	.LFE42:
 831 03da 00BF     		.align	2
 832              		.global	ADC_RegularChannelConfig
 833              		.thumb
 834              		.thumb_func
 836              	ADC_RegularChannelConfig:
 837              	.LFB43:
 553:../src/stm32f10x_adc.c **** 
 554:../src/stm32f10x_adc.c **** /**
 555:../src/stm32f10x_adc.c ****   * @brief  Configures for the selected ADC regular channel its corresponding
 556:../src/stm32f10x_adc.c ****   *         rank in the sequencer and its sample time.
 557:../src/stm32f10x_adc.c ****   * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
 558:../src/stm32f10x_adc.c ****   * @param  ADC_Channel: the ADC channel to configure. 
 559:../src/stm32f10x_adc.c ****   *   This parameter can be one of the following values:
 560:../src/stm32f10x_adc.c ****   *     @arg ADC_Channel_0: ADC Channel0 selected
 561:../src/stm32f10x_adc.c ****   *     @arg ADC_Channel_1: ADC Channel1 selected
 562:../src/stm32f10x_adc.c ****   *     @arg ADC_Channel_2: ADC Channel2 selected
 563:../src/stm32f10x_adc.c ****   *     @arg ADC_Channel_3: ADC Channel3 selected
 564:../src/stm32f10x_adc.c ****   *     @arg ADC_Channel_4: ADC Channel4 selected
 565:../src/stm32f10x_adc.c ****   *     @arg ADC_Channel_5: ADC Channel5 selected
 566:../src/stm32f10x_adc.c ****   *     @arg ADC_Channel_6: ADC Channel6 selected
 567:../src/stm32f10x_adc.c ****   *     @arg ADC_Channel_7: ADC Channel7 selected
 568:../src/stm32f10x_adc.c ****   *     @arg ADC_Channel_8: ADC Channel8 selected
 569:../src/stm32f10x_adc.c ****   *     @arg ADC_Channel_9: ADC Channel9 selected
 570:../src/stm32f10x_adc.c ****   *     @arg ADC_Channel_10: ADC Channel10 selected
 571:../src/stm32f10x_adc.c ****   *     @arg ADC_Channel_11: ADC Channel11 selected
 572:../src/stm32f10x_adc.c ****   *     @arg ADC_Channel_12: ADC Channel12 selected
 573:../src/stm32f10x_adc.c ****   *     @arg ADC_Channel_13: ADC Channel13 selected
 574:../src/stm32f10x_adc.c ****   *     @arg ADC_Channel_14: ADC Channel14 selected
 575:../src/stm32f10x_adc.c ****   *     @arg ADC_Channel_15: ADC Channel15 selected
 576:../src/stm32f10x_adc.c ****   *     @arg ADC_Channel_16: ADC Channel16 selected
 577:../src/stm32f10x_adc.c ****   *     @arg ADC_Channel_17: ADC Channel17 selected
 578:../src/stm32f10x_adc.c ****   * @param  Rank: The rank in the regular group sequencer. This parameter must be between 1 to 16.
 579:../src/stm32f10x_adc.c ****   * @param  ADC_SampleTime: The sample time value to be set for the selected channel. 
 580:../src/stm32f10x_adc.c ****   *   This parameter can be one of the following values:
 581:../src/stm32f10x_adc.c ****   *     @arg ADC_SampleTime_1Cycles5: Sample time equal to 1.5 cycles
 582:../src/stm32f10x_adc.c ****   *     @arg ADC_SampleTime_7Cycles5: Sample time equal to 7.5 cycles
 583:../src/stm32f10x_adc.c ****   *     @arg ADC_SampleTime_13Cycles5: Sample time equal to 13.5 cycles
 584:../src/stm32f10x_adc.c ****   *     @arg ADC_SampleTime_28Cycles5: Sample time equal to 28.5 cycles	
 585:../src/stm32f10x_adc.c ****   *     @arg ADC_SampleTime_41Cycles5: Sample time equal to 41.5 cycles	
 586:../src/stm32f10x_adc.c ****   *     @arg ADC_SampleTime_55Cycles5: Sample time equal to 55.5 cycles	
 587:../src/stm32f10x_adc.c ****   *     @arg ADC_SampleTime_71Cycles5: Sample time equal to 71.5 cycles	
 588:../src/stm32f10x_adc.c ****   *     @arg ADC_SampleTime_239Cycles5: Sample time equal to 239.5 cycles	
 589:../src/stm32f10x_adc.c ****   * @retval None
 590:../src/stm32f10x_adc.c ****   */
 591:../src/stm32f10x_adc.c **** void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_Sam
 592:../src/stm32f10x_adc.c **** {
 838              		.loc 1 592 0
 839              		.cfi_startproc
 840              		@ args = 0, pretend = 0, frame = 16
 841              		@ frame_needed = 1, uses_anonymous_args = 0
 842              		@ link register save eliminated.
 843 03dc 80B4     		push	{r7}
 844              	.LCFI42:
 845              		.cfi_def_cfa_offset 4
 846              		.cfi_offset 7, -4
 847 03de 85B0     		sub	sp, sp, #20
 848              	.LCFI43:
 849              		.cfi_def_cfa_offset 24
 850 03e0 00AF     		add	r7, sp, #0
 851              	.LCFI44:
 852              		.cfi_def_cfa_register 7
 853 03e2 7860     		str	r0, [r7, #4]
 854 03e4 F970     		strb	r1, [r7, #3]
 855 03e6 BA70     		strb	r2, [r7, #2]
 856 03e8 7B70     		strb	r3, [r7, #1]
 593:../src/stm32f10x_adc.c ****   uint32_t tmpreg1 = 0, tmpreg2 = 0;
 857              		.loc 1 593 0
 858 03ea 4FF00003 		mov	r3, #0
 859 03ee FB60     		str	r3, [r7, #12]
 860 03f0 4FF00003 		mov	r3, #0
 861 03f4 BB60     		str	r3, [r7, #8]
 594:../src/stm32f10x_adc.c ****   /* Check the parameters */
 595:../src/stm32f10x_adc.c ****   assert_param(IS_ADC_ALL_PERIPH(ADCx));
 596:../src/stm32f10x_adc.c ****   assert_param(IS_ADC_CHANNEL(ADC_Channel));
 597:../src/stm32f10x_adc.c ****   assert_param(IS_ADC_REGULAR_RANK(Rank));
 598:../src/stm32f10x_adc.c ****   assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
 599:../src/stm32f10x_adc.c ****   /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
 600:../src/stm32f10x_adc.c ****   if (ADC_Channel > ADC_Channel_9)
 862              		.loc 1 600 0
 863 03f6 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 864 03f8 092B     		cmp	r3, #9
 865 03fa 27D9     		bls	.L35
 601:../src/stm32f10x_adc.c ****   {
 602:../src/stm32f10x_adc.c ****     /* Get the old register value */
 603:../src/stm32f10x_adc.c ****     tmpreg1 = ADCx->SMPR1;
 866              		.loc 1 603 0
 867 03fc 7B68     		ldr	r3, [r7, #4]
 868 03fe DB68     		ldr	r3, [r3, #12]
 869 0400 FB60     		str	r3, [r7, #12]
 604:../src/stm32f10x_adc.c ****     /* Calculate the mask to clear */
 605:../src/stm32f10x_adc.c ****     tmpreg2 = SMPR1_SMP_Set << (3 * (ADC_Channel - 10));
 870              		.loc 1 605 0
 871 0402 FA78     		ldrb	r2, [r7, #3]	@ zero_extendqisi2
 872 0404 1346     		mov	r3, r2
 873 0406 4FEA4303 		lsl	r3, r3, #1
 874 040a 9B18     		adds	r3, r3, r2
 875 040c A3F11E03 		sub	r3, r3, #30
 876 0410 4FF00702 		mov	r2, #7
 877 0414 02FA03F3 		lsl	r3, r2, r3
 878 0418 BB60     		str	r3, [r7, #8]
 606:../src/stm32f10x_adc.c ****     /* Clear the old channel sample time */
 607:../src/stm32f10x_adc.c ****     tmpreg1 &= ~tmpreg2;
 879              		.loc 1 607 0
 880 041a BB68     		ldr	r3, [r7, #8]
 881 041c 6FEA0303 		mvn	r3, r3
 882 0420 FA68     		ldr	r2, [r7, #12]
 883 0422 1340     		ands	r3, r3, r2
 884 0424 FB60     		str	r3, [r7, #12]
 608:../src/stm32f10x_adc.c ****     /* Calculate the mask to set */
 609:../src/stm32f10x_adc.c ****     tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 10));
 885              		.loc 1 609 0
 886 0426 7978     		ldrb	r1, [r7, #1]	@ zero_extendqisi2
 887 0428 FA78     		ldrb	r2, [r7, #3]	@ zero_extendqisi2
 888 042a 1346     		mov	r3, r2
 889 042c 4FEA4303 		lsl	r3, r3, #1
 890 0430 9B18     		adds	r3, r3, r2
 891 0432 A3F11E03 		sub	r3, r3, #30
 892 0436 01FA03F3 		lsl	r3, r1, r3
 893 043a BB60     		str	r3, [r7, #8]
 610:../src/stm32f10x_adc.c ****     /* Set the new channel sample time */
 611:../src/stm32f10x_adc.c ****     tmpreg1 |= tmpreg2;
 894              		.loc 1 611 0
 895 043c FA68     		ldr	r2, [r7, #12]
 896 043e BB68     		ldr	r3, [r7, #8]
 897 0440 1343     		orrs	r3, r3, r2
 898 0442 FB60     		str	r3, [r7, #12]
 612:../src/stm32f10x_adc.c ****     /* Store the new register value */
 613:../src/stm32f10x_adc.c ****     ADCx->SMPR1 = tmpreg1;
 899              		.loc 1 613 0
 900 0444 7B68     		ldr	r3, [r7, #4]
 901 0446 FA68     		ldr	r2, [r7, #12]
 902 0448 DA60     		str	r2, [r3, #12]
 903 044a 22E0     		b	.L36
 904              	.L35:
 614:../src/stm32f10x_adc.c ****   }
 615:../src/stm32f10x_adc.c ****   else /* ADC_Channel include in ADC_Channel_[0..9] */
 616:../src/stm32f10x_adc.c ****   {
 617:../src/stm32f10x_adc.c ****     /* Get the old register value */
 618:../src/stm32f10x_adc.c ****     tmpreg1 = ADCx->SMPR2;
 905              		.loc 1 618 0
 906 044c 7B68     		ldr	r3, [r7, #4]
 907 044e 1B69     		ldr	r3, [r3, #16]
 908 0450 FB60     		str	r3, [r7, #12]
 619:../src/stm32f10x_adc.c ****     /* Calculate the mask to clear */
 620:../src/stm32f10x_adc.c ****     tmpreg2 = SMPR2_SMP_Set << (3 * ADC_Channel);
 909              		.loc 1 620 0
 910 0452 FA78     		ldrb	r2, [r7, #3]	@ zero_extendqisi2
 911 0454 1346     		mov	r3, r2
 912 0456 4FEA4303 		lsl	r3, r3, #1
 913 045a 9B18     		adds	r3, r3, r2
 914 045c 4FF00702 		mov	r2, #7
 915 0460 02FA03F3 		lsl	r3, r2, r3
 916 0464 BB60     		str	r3, [r7, #8]
 621:../src/stm32f10x_adc.c ****     /* Clear the old channel sample time */
 622:../src/stm32f10x_adc.c ****     tmpreg1 &= ~tmpreg2;
 917              		.loc 1 622 0
 918 0466 BB68     		ldr	r3, [r7, #8]
 919 0468 6FEA0303 		mvn	r3, r3
 920 046c FA68     		ldr	r2, [r7, #12]
 921 046e 1340     		ands	r3, r3, r2
 922 0470 FB60     		str	r3, [r7, #12]
 623:../src/stm32f10x_adc.c ****     /* Calculate the mask to set */
 624:../src/stm32f10x_adc.c ****     tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
 923              		.loc 1 624 0
 924 0472 7978     		ldrb	r1, [r7, #1]	@ zero_extendqisi2
 925 0474 FA78     		ldrb	r2, [r7, #3]	@ zero_extendqisi2
 926 0476 1346     		mov	r3, r2
 927 0478 4FEA4303 		lsl	r3, r3, #1
 928 047c 9B18     		adds	r3, r3, r2
 929 047e 01FA03F3 		lsl	r3, r1, r3
 930 0482 BB60     		str	r3, [r7, #8]
 625:../src/stm32f10x_adc.c ****     /* Set the new channel sample time */
 626:../src/stm32f10x_adc.c ****     tmpreg1 |= tmpreg2;
 931              		.loc 1 626 0
 932 0484 FA68     		ldr	r2, [r7, #12]
 933 0486 BB68     		ldr	r3, [r7, #8]
 934 0488 1343     		orrs	r3, r3, r2
 935 048a FB60     		str	r3, [r7, #12]
 627:../src/stm32f10x_adc.c ****     /* Store the new register value */
 628:../src/stm32f10x_adc.c ****     ADCx->SMPR2 = tmpreg1;
 936              		.loc 1 628 0
 937 048c 7B68     		ldr	r3, [r7, #4]
 938 048e FA68     		ldr	r2, [r7, #12]
 939 0490 1A61     		str	r2, [r3, #16]
 940              	.L36:
 629:../src/stm32f10x_adc.c ****   }
 630:../src/stm32f10x_adc.c ****   /* For Rank 1 to 6 */
 631:../src/stm32f10x_adc.c ****   if (Rank < 7)
 941              		.loc 1 631 0
 942 0492 BB78     		ldrb	r3, [r7, #2]	@ zero_extendqisi2
 943 0494 062B     		cmp	r3, #6
 944 0496 27D8     		bhi	.L37
 632:../src/stm32f10x_adc.c ****   {
 633:../src/stm32f10x_adc.c ****     /* Get the old register value */
 634:../src/stm32f10x_adc.c ****     tmpreg1 = ADCx->SQR3;
 945              		.loc 1 634 0
 946 0498 7B68     		ldr	r3, [r7, #4]
 947 049a 5B6B     		ldr	r3, [r3, #52]
 948 049c FB60     		str	r3, [r7, #12]
 635:../src/stm32f10x_adc.c ****     /* Calculate the mask to clear */
 636:../src/stm32f10x_adc.c ****     tmpreg2 = SQR3_SQ_Set << (5 * (Rank - 1));
 949              		.loc 1 636 0
 950 049e BB78     		ldrb	r3, [r7, #2]	@ zero_extendqisi2
 951 04a0 03F1FF32 		add	r2, r3, #-1
 952 04a4 1346     		mov	r3, r2
 953 04a6 4FEA8303 		lsl	r3, r3, #2
 954 04aa 9B18     		adds	r3, r3, r2
 955 04ac 4FF01F02 		mov	r2, #31
 956 04b0 02FA03F3 		lsl	r3, r2, r3
 957 04b4 BB60     		str	r3, [r7, #8]
 637:../src/stm32f10x_adc.c ****     /* Clear the old SQx bits for the selected rank */
 638:../src/stm32f10x_adc.c ****     tmpreg1 &= ~tmpreg2;
 958              		.loc 1 638 0
 959 04b6 BB68     		ldr	r3, [r7, #8]
 960 04b8 6FEA0303 		mvn	r3, r3
 961 04bc FA68     		ldr	r2, [r7, #12]
 962 04be 1340     		ands	r3, r3, r2
 963 04c0 FB60     		str	r3, [r7, #12]
 639:../src/stm32f10x_adc.c ****     /* Calculate the mask to set */
 640:../src/stm32f10x_adc.c ****     tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 1));
 964              		.loc 1 640 0
 965 04c2 F978     		ldrb	r1, [r7, #3]	@ zero_extendqisi2
 966 04c4 BB78     		ldrb	r3, [r7, #2]	@ zero_extendqisi2
 967 04c6 03F1FF32 		add	r2, r3, #-1
 968 04ca 1346     		mov	r3, r2
 969 04cc 4FEA8303 		lsl	r3, r3, #2
 970 04d0 9B18     		adds	r3, r3, r2
 971 04d2 01FA03F3 		lsl	r3, r1, r3
 972 04d6 BB60     		str	r3, [r7, #8]
 641:../src/stm32f10x_adc.c ****     /* Set the SQx bits for the selected rank */
 642:../src/stm32f10x_adc.c ****     tmpreg1 |= tmpreg2;
 973              		.loc 1 642 0
 974 04d8 FA68     		ldr	r2, [r7, #12]
 975 04da BB68     		ldr	r3, [r7, #8]
 976 04dc 1343     		orrs	r3, r3, r2
 977 04de FB60     		str	r3, [r7, #12]
 643:../src/stm32f10x_adc.c ****     /* Store the new register value */
 644:../src/stm32f10x_adc.c ****     ADCx->SQR3 = tmpreg1;
 978              		.loc 1 644 0
 979 04e0 7B68     		ldr	r3, [r7, #4]
 980 04e2 FA68     		ldr	r2, [r7, #12]
 981 04e4 5A63     		str	r2, [r3, #52]
 982 04e6 51E0     		b	.L34
 983              	.L37:
 645:../src/stm32f10x_adc.c ****   }
 646:../src/stm32f10x_adc.c ****   /* For Rank 7 to 12 */
 647:../src/stm32f10x_adc.c ****   else if (Rank < 13)
 984              		.loc 1 647 0
 985 04e8 BB78     		ldrb	r3, [r7, #2]	@ zero_extendqisi2
 986 04ea 0C2B     		cmp	r3, #12
 987 04ec 27D8     		bhi	.L39
 648:../src/stm32f10x_adc.c ****   {
 649:../src/stm32f10x_adc.c ****     /* Get the old register value */
 650:../src/stm32f10x_adc.c ****     tmpreg1 = ADCx->SQR2;
 988              		.loc 1 650 0
 989 04ee 7B68     		ldr	r3, [r7, #4]
 990 04f0 1B6B     		ldr	r3, [r3, #48]
 991 04f2 FB60     		str	r3, [r7, #12]
 651:../src/stm32f10x_adc.c ****     /* Calculate the mask to clear */
 652:../src/stm32f10x_adc.c ****     tmpreg2 = SQR2_SQ_Set << (5 * (Rank - 7));
 992              		.loc 1 652 0
 993 04f4 BA78     		ldrb	r2, [r7, #2]	@ zero_extendqisi2
 994 04f6 1346     		mov	r3, r2
 995 04f8 4FEA8303 		lsl	r3, r3, #2
 996 04fc 9B18     		adds	r3, r3, r2
 997 04fe A3F12303 		sub	r3, r3, #35
 998 0502 4FF01F02 		mov	r2, #31
 999 0506 02FA03F3 		lsl	r3, r2, r3
 1000 050a BB60     		str	r3, [r7, #8]
 653:../src/stm32f10x_adc.c ****     /* Clear the old SQx bits for the selected rank */
 654:../src/stm32f10x_adc.c ****     tmpreg1 &= ~tmpreg2;
 1001              		.loc 1 654 0
 1002 050c BB68     		ldr	r3, [r7, #8]
 1003 050e 6FEA0303 		mvn	r3, r3
 1004 0512 FA68     		ldr	r2, [r7, #12]
 1005 0514 1340     		ands	r3, r3, r2
 1006 0516 FB60     		str	r3, [r7, #12]
 655:../src/stm32f10x_adc.c ****     /* Calculate the mask to set */
 656:../src/stm32f10x_adc.c ****     tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 7));
 1007              		.loc 1 656 0
 1008 0518 F978     		ldrb	r1, [r7, #3]	@ zero_extendqisi2
 1009 051a BA78     		ldrb	r2, [r7, #2]	@ zero_extendqisi2
 1010 051c 1346     		mov	r3, r2
 1011 051e 4FEA8303 		lsl	r3, r3, #2
 1012 0522 9B18     		adds	r3, r3, r2
 1013 0524 A3F12303 		sub	r3, r3, #35
 1014 0528 01FA03F3 		lsl	r3, r1, r3
 1015 052c BB60     		str	r3, [r7, #8]
 657:../src/stm32f10x_adc.c ****     /* Set the SQx bits for the selected rank */
 658:../src/stm32f10x_adc.c ****     tmpreg1 |= tmpreg2;
 1016              		.loc 1 658 0
 1017 052e FA68     		ldr	r2, [r7, #12]
 1018 0530 BB68     		ldr	r3, [r7, #8]
 1019 0532 1343     		orrs	r3, r3, r2
 1020 0534 FB60     		str	r3, [r7, #12]
 659:../src/stm32f10x_adc.c ****     /* Store the new register value */
 660:../src/stm32f10x_adc.c ****     ADCx->SQR2 = tmpreg1;
 1021              		.loc 1 660 0
 1022 0536 7B68     		ldr	r3, [r7, #4]
 1023 0538 FA68     		ldr	r2, [r7, #12]
 1024 053a 1A63     		str	r2, [r3, #48]
 1025 053c 26E0     		b	.L34
 1026              	.L39:
 661:../src/stm32f10x_adc.c ****   }
 662:../src/stm32f10x_adc.c ****   /* For Rank 13 to 16 */
 663:../src/stm32f10x_adc.c ****   else
 664:../src/stm32f10x_adc.c ****   {
 665:../src/stm32f10x_adc.c ****     /* Get the old register value */
 666:../src/stm32f10x_adc.c ****     tmpreg1 = ADCx->SQR1;
 1027              		.loc 1 666 0
 1028 053e 7B68     		ldr	r3, [r7, #4]
 1029 0540 DB6A     		ldr	r3, [r3, #44]
 1030 0542 FB60     		str	r3, [r7, #12]
 667:../src/stm32f10x_adc.c ****     /* Calculate the mask to clear */
 668:../src/stm32f10x_adc.c ****     tmpreg2 = SQR1_SQ_Set << (5 * (Rank - 13));
 1031              		.loc 1 668 0
 1032 0544 BA78     		ldrb	r2, [r7, #2]	@ zero_extendqisi2
 1033 0546 1346     		mov	r3, r2
 1034 0548 4FEA8303 		lsl	r3, r3, #2
 1035 054c 9B18     		adds	r3, r3, r2
 1036 054e A3F14103 		sub	r3, r3, #65
 1037 0552 4FF01F02 		mov	r2, #31
 1038 0556 02FA03F3 		lsl	r3, r2, r3
 1039 055a BB60     		str	r3, [r7, #8]
 669:../src/stm32f10x_adc.c ****     /* Clear the old SQx bits for the selected rank */
 670:../src/stm32f10x_adc.c ****     tmpreg1 &= ~tmpreg2;
 1040              		.loc 1 670 0
 1041 055c BB68     		ldr	r3, [r7, #8]
 1042 055e 6FEA0303 		mvn	r3, r3
 1043 0562 FA68     		ldr	r2, [r7, #12]
 1044 0564 1340     		ands	r3, r3, r2
 1045 0566 FB60     		str	r3, [r7, #12]
 671:../src/stm32f10x_adc.c ****     /* Calculate the mask to set */
 672:../src/stm32f10x_adc.c ****     tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 13));
 1046              		.loc 1 672 0
 1047 0568 F978     		ldrb	r1, [r7, #3]	@ zero_extendqisi2
 1048 056a BA78     		ldrb	r2, [r7, #2]	@ zero_extendqisi2
 1049 056c 1346     		mov	r3, r2
 1050 056e 4FEA8303 		lsl	r3, r3, #2
 1051 0572 9B18     		adds	r3, r3, r2
 1052 0574 A3F14103 		sub	r3, r3, #65
 1053 0578 01FA03F3 		lsl	r3, r1, r3
 1054 057c BB60     		str	r3, [r7, #8]
 673:../src/stm32f10x_adc.c ****     /* Set the SQx bits for the selected rank */
 674:../src/stm32f10x_adc.c ****     tmpreg1 |= tmpreg2;
 1055              		.loc 1 674 0
 1056 057e FA68     		ldr	r2, [r7, #12]
 1057 0580 BB68     		ldr	r3, [r7, #8]
 1058 0582 1343     		orrs	r3, r3, r2
 1059 0584 FB60     		str	r3, [r7, #12]
 675:../src/stm32f10x_adc.c ****     /* Store the new register value */
 676:../src/stm32f10x_adc.c ****     ADCx->SQR1 = tmpreg1;
 1060              		.loc 1 676 0
 1061 0586 7B68     		ldr	r3, [r7, #4]
 1062 0588 FA68     		ldr	r2, [r7, #12]
 1063 058a DA62     		str	r2, [r3, #44]
 1064              	.L34:
 677:../src/stm32f10x_adc.c ****   }
 678:../src/stm32f10x_adc.c **** }
 1065              		.loc 1 678 0
 1066 058c 07F11407 		add	r7, r7, #20
 1067 0590 BD46     		mov	sp, r7
 1068 0592 80BC     		pop	{r7}
 1069 0594 7047     		bx	lr
 1070              		.cfi_endproc
 1071              	.LFE43:
 1073 0596 00BF     		.align	2
 1074              		.global	ADC_ExternalTrigConvCmd
 1075              		.thumb
 1076              		.thumb_func
 1078              	ADC_ExternalTrigConvCmd:
 1079              	.LFB44:
 679:../src/stm32f10x_adc.c **** 
 680:../src/stm32f10x_adc.c **** /**
 681:../src/stm32f10x_adc.c ****   * @brief  Enables or disables the ADCx conversion through external trigger.
 682:../src/stm32f10x_adc.c ****   * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
 683:../src/stm32f10x_adc.c ****   * @param  NewState: new state of the selected ADC external trigger start of conversion.
 684:../src/stm32f10x_adc.c ****   *   This parameter can be: ENABLE or DISABLE.
 685:../src/stm32f10x_adc.c ****   * @retval None
 686:../src/stm32f10x_adc.c ****   */
 687:../src/stm32f10x_adc.c **** void ADC_ExternalTrigConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
 688:../src/stm32f10x_adc.c **** {
 1080              		.loc 1 688 0
 1081              		.cfi_startproc
 1082              		@ args = 0, pretend = 0, frame = 8
 1083              		@ frame_needed = 1, uses_anonymous_args = 0
 1084              		@ link register save eliminated.
 1085 0598 80B4     		push	{r7}
 1086              	.LCFI45:
 1087              		.cfi_def_cfa_offset 4
 1088              		.cfi_offset 7, -4
 1089 059a 83B0     		sub	sp, sp, #12
 1090              	.LCFI46:
 1091              		.cfi_def_cfa_offset 16
 1092 059c 00AF     		add	r7, sp, #0
 1093              	.LCFI47:
 1094              		.cfi_def_cfa_register 7
 1095 059e 7860     		str	r0, [r7, #4]
 1096 05a0 0B46     		mov	r3, r1
 1097 05a2 FB70     		strb	r3, [r7, #3]
 689:../src/stm32f10x_adc.c ****   /* Check the parameters */
 690:../src/stm32f10x_adc.c ****   assert_param(IS_ADC_ALL_PERIPH(ADCx));
 691:../src/stm32f10x_adc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 692:../src/stm32f10x_adc.c ****   if (NewState != DISABLE)
 1098              		.loc 1 692 0
 1099 05a4 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1100 05a6 002B     		cmp	r3, #0
 1101 05a8 06D0     		beq	.L41
 693:../src/stm32f10x_adc.c ****   {
 694:../src/stm32f10x_adc.c ****     /* Enable the selected ADC conversion on external event */
 695:../src/stm32f10x_adc.c ****     ADCx->CR2 |= CR2_EXTTRIG_Set;
 1102              		.loc 1 695 0
 1103 05aa 7B68     		ldr	r3, [r7, #4]
 1104 05ac 9B68     		ldr	r3, [r3, #8]
 1105 05ae 43F48012 		orr	r2, r3, #1048576
 1106 05b2 7B68     		ldr	r3, [r7, #4]
 1107 05b4 9A60     		str	r2, [r3, #8]
 1108 05b6 05E0     		b	.L40
 1109              	.L41:
 696:../src/stm32f10x_adc.c ****   }
 697:../src/stm32f10x_adc.c ****   else
 698:../src/stm32f10x_adc.c ****   {
 699:../src/stm32f10x_adc.c ****     /* Disable the selected ADC conversion on external event */
 700:../src/stm32f10x_adc.c ****     ADCx->CR2 &= CR2_EXTTRIG_Reset;
 1110              		.loc 1 700 0
 1111 05b8 7B68     		ldr	r3, [r7, #4]
 1112 05ba 9B68     		ldr	r3, [r3, #8]
 1113 05bc 23F48012 		bic	r2, r3, #1048576
 1114 05c0 7B68     		ldr	r3, [r7, #4]
 1115 05c2 9A60     		str	r2, [r3, #8]
 1116              	.L40:
 701:../src/stm32f10x_adc.c ****   }
 702:../src/stm32f10x_adc.c **** }
 1117              		.loc 1 702 0
 1118 05c4 07F10C07 		add	r7, r7, #12
 1119 05c8 BD46     		mov	sp, r7
 1120 05ca 80BC     		pop	{r7}
 1121 05cc 7047     		bx	lr
 1122              		.cfi_endproc
 1123              	.LFE44:
 1125 05ce 00BF     		.align	2
 1126              		.global	ADC_GetConversionValue
 1127              		.thumb
 1128              		.thumb_func
 1130              	ADC_GetConversionValue:
 1131              	.LFB45:
 703:../src/stm32f10x_adc.c **** 
 704:../src/stm32f10x_adc.c **** /**
 705:../src/stm32f10x_adc.c ****   * @brief  Returns the last ADCx conversion result data for regular channel.
 706:../src/stm32f10x_adc.c ****   * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
 707:../src/stm32f10x_adc.c ****   * @retval The Data conversion value.
 708:../src/stm32f10x_adc.c ****   */
 709:../src/stm32f10x_adc.c **** uint16_t ADC_GetConversionValue(ADC_TypeDef* ADCx)
 710:../src/stm32f10x_adc.c **** {
 1132              		.loc 1 710 0
 1133              		.cfi_startproc
 1134              		@ args = 0, pretend = 0, frame = 8
 1135              		@ frame_needed = 1, uses_anonymous_args = 0
 1136              		@ link register save eliminated.
 1137 05d0 80B4     		push	{r7}
 1138              	.LCFI48:
 1139              		.cfi_def_cfa_offset 4
 1140              		.cfi_offset 7, -4
 1141 05d2 83B0     		sub	sp, sp, #12
 1142              	.LCFI49:
 1143              		.cfi_def_cfa_offset 16
 1144 05d4 00AF     		add	r7, sp, #0
 1145              	.LCFI50:
 1146              		.cfi_def_cfa_register 7
 1147 05d6 7860     		str	r0, [r7, #4]
 711:../src/stm32f10x_adc.c ****   /* Check the parameters */
 712:../src/stm32f10x_adc.c ****   assert_param(IS_ADC_ALL_PERIPH(ADCx));
 713:../src/stm32f10x_adc.c ****   /* Return the selected ADC conversion value */
 714:../src/stm32f10x_adc.c ****   return (uint16_t) ADCx->DR;
 1148              		.loc 1 714 0
 1149 05d8 7B68     		ldr	r3, [r7, #4]
 1150 05da DB6C     		ldr	r3, [r3, #76]
 1151 05dc 9BB2     		uxth	r3, r3
 715:../src/stm32f10x_adc.c **** }
 1152              		.loc 1 715 0
 1153 05de 1846     		mov	r0, r3
 1154 05e0 07F10C07 		add	r7, r7, #12
 1155 05e4 BD46     		mov	sp, r7
 1156 05e6 80BC     		pop	{r7}
 1157 05e8 7047     		bx	lr
 1158              		.cfi_endproc
 1159              	.LFE45:
 1161 05ea 00BF     		.align	2
 1162              		.global	ADC_GetDualModeConversionValue
 1163              		.thumb
 1164              		.thumb_func
 1166              	ADC_GetDualModeConversionValue:
 1167              	.LFB46:
 716:../src/stm32f10x_adc.c **** 
 717:../src/stm32f10x_adc.c **** /**
 718:../src/stm32f10x_adc.c ****   * @brief  Returns the last ADC1 and ADC2 conversion result data in dual mode.
 719:../src/stm32f10x_adc.c ****   * @retval The Data conversion value.
 720:../src/stm32f10x_adc.c ****   */
 721:../src/stm32f10x_adc.c **** uint32_t ADC_GetDualModeConversionValue(void)
 722:../src/stm32f10x_adc.c **** {
 1168              		.loc 1 722 0
 1169              		.cfi_startproc
 1170              		@ args = 0, pretend = 0, frame = 0
 1171              		@ frame_needed = 1, uses_anonymous_args = 0
 1172              		@ link register save eliminated.
 1173 05ec 80B4     		push	{r7}
 1174              	.LCFI51:
 1175              		.cfi_def_cfa_offset 4
 1176              		.cfi_offset 7, -4
 1177 05ee 00AF     		add	r7, sp, #0
 1178              	.LCFI52:
 1179              		.cfi_def_cfa_register 7
 723:../src/stm32f10x_adc.c ****   /* Return the dual mode conversion value */
 724:../src/stm32f10x_adc.c ****   return (*(__IO uint32_t *) DR_ADDRESS);
 1180              		.loc 1 724 0
 1181 05f0 42F24C43 		movw	r3, #9292
 1182 05f4 C4F20103 		movt	r3, 16385
 1183 05f8 1B68     		ldr	r3, [r3, #0]
 725:../src/stm32f10x_adc.c **** }
 1184              		.loc 1 725 0
 1185 05fa 1846     		mov	r0, r3
 1186 05fc BD46     		mov	sp, r7
 1187 05fe 80BC     		pop	{r7}
 1188 0600 7047     		bx	lr
 1189              		.cfi_endproc
 1190              	.LFE46:
 1192 0602 00BF     		.align	2
 1193              		.global	ADC_AutoInjectedConvCmd
 1194              		.thumb
 1195              		.thumb_func
 1197              	ADC_AutoInjectedConvCmd:
 1198              	.LFB47:
 726:../src/stm32f10x_adc.c **** 
 727:../src/stm32f10x_adc.c **** /**
 728:../src/stm32f10x_adc.c ****   * @brief  Enables or disables the selected ADC automatic injected group
 729:../src/stm32f10x_adc.c ****   *         conversion after regular one.
 730:../src/stm32f10x_adc.c ****   * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
 731:../src/stm32f10x_adc.c ****   * @param  NewState: new state of the selected ADC auto injected conversion
 732:../src/stm32f10x_adc.c ****   *   This parameter can be: ENABLE or DISABLE.
 733:../src/stm32f10x_adc.c ****   * @retval None
 734:../src/stm32f10x_adc.c ****   */
 735:../src/stm32f10x_adc.c **** void ADC_AutoInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
 736:../src/stm32f10x_adc.c **** {
 1199              		.loc 1 736 0
 1200              		.cfi_startproc
 1201              		@ args = 0, pretend = 0, frame = 8
 1202              		@ frame_needed = 1, uses_anonymous_args = 0
 1203              		@ link register save eliminated.
 1204 0604 80B4     		push	{r7}
 1205              	.LCFI53:
 1206              		.cfi_def_cfa_offset 4
 1207              		.cfi_offset 7, -4
 1208 0606 83B0     		sub	sp, sp, #12
 1209              	.LCFI54:
 1210              		.cfi_def_cfa_offset 16
 1211 0608 00AF     		add	r7, sp, #0
 1212              	.LCFI55:
 1213              		.cfi_def_cfa_register 7
 1214 060a 7860     		str	r0, [r7, #4]
 1215 060c 0B46     		mov	r3, r1
 1216 060e FB70     		strb	r3, [r7, #3]
 737:../src/stm32f10x_adc.c ****   /* Check the parameters */
 738:../src/stm32f10x_adc.c ****   assert_param(IS_ADC_ALL_PERIPH(ADCx));
 739:../src/stm32f10x_adc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 740:../src/stm32f10x_adc.c ****   if (NewState != DISABLE)
 1217              		.loc 1 740 0
 1218 0610 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1219 0612 002B     		cmp	r3, #0
 1220 0614 06D0     		beq	.L46
 741:../src/stm32f10x_adc.c ****   {
 742:../src/stm32f10x_adc.c ****     /* Enable the selected ADC automatic injected group conversion */
 743:../src/stm32f10x_adc.c ****     ADCx->CR1 |= CR1_JAUTO_Set;
 1221              		.loc 1 743 0
 1222 0616 7B68     		ldr	r3, [r7, #4]
 1223 0618 5B68     		ldr	r3, [r3, #4]
 1224 061a 43F48062 		orr	r2, r3, #1024
 1225 061e 7B68     		ldr	r3, [r7, #4]
 1226 0620 5A60     		str	r2, [r3, #4]
 1227 0622 05E0     		b	.L45
 1228              	.L46:
 744:../src/stm32f10x_adc.c ****   }
 745:../src/stm32f10x_adc.c ****   else
 746:../src/stm32f10x_adc.c ****   {
 747:../src/stm32f10x_adc.c ****     /* Disable the selected ADC automatic injected group conversion */
 748:../src/stm32f10x_adc.c ****     ADCx->CR1 &= CR1_JAUTO_Reset;
 1229              		.loc 1 748 0
 1230 0624 7B68     		ldr	r3, [r7, #4]
 1231 0626 5B68     		ldr	r3, [r3, #4]
 1232 0628 23F48062 		bic	r2, r3, #1024
 1233 062c 7B68     		ldr	r3, [r7, #4]
 1234 062e 5A60     		str	r2, [r3, #4]
 1235              	.L45:
 749:../src/stm32f10x_adc.c ****   }
 750:../src/stm32f10x_adc.c **** }
 1236              		.loc 1 750 0
 1237 0630 07F10C07 		add	r7, r7, #12
 1238 0634 BD46     		mov	sp, r7
 1239 0636 80BC     		pop	{r7}
 1240 0638 7047     		bx	lr
 1241              		.cfi_endproc
 1242              	.LFE47:
 1244 063a 00BF     		.align	2
 1245              		.global	ADC_InjectedDiscModeCmd
 1246              		.thumb
 1247              		.thumb_func
 1249              	ADC_InjectedDiscModeCmd:
 1250              	.LFB48:
 751:../src/stm32f10x_adc.c **** 
 752:../src/stm32f10x_adc.c **** /**
 753:../src/stm32f10x_adc.c ****   * @brief  Enables or disables the discontinuous mode for injected group
 754:../src/stm32f10x_adc.c ****   *         channel for the specified ADC
 755:../src/stm32f10x_adc.c ****   * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
 756:../src/stm32f10x_adc.c ****   * @param  NewState: new state of the selected ADC discontinuous mode
 757:../src/stm32f10x_adc.c ****   *         on injected group channel.
 758:../src/stm32f10x_adc.c ****   *   This parameter can be: ENABLE or DISABLE.
 759:../src/stm32f10x_adc.c ****   * @retval None
 760:../src/stm32f10x_adc.c ****   */
 761:../src/stm32f10x_adc.c **** void ADC_InjectedDiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
 762:../src/stm32f10x_adc.c **** {
 1251              		.loc 1 762 0
 1252              		.cfi_startproc
 1253              		@ args = 0, pretend = 0, frame = 8
 1254              		@ frame_needed = 1, uses_anonymous_args = 0
 1255              		@ link register save eliminated.
 1256 063c 80B4     		push	{r7}
 1257              	.LCFI56:
 1258              		.cfi_def_cfa_offset 4
 1259              		.cfi_offset 7, -4
 1260 063e 83B0     		sub	sp, sp, #12
 1261              	.LCFI57:
 1262              		.cfi_def_cfa_offset 16
 1263 0640 00AF     		add	r7, sp, #0
 1264              	.LCFI58:
 1265              		.cfi_def_cfa_register 7
 1266 0642 7860     		str	r0, [r7, #4]
 1267 0644 0B46     		mov	r3, r1
 1268 0646 FB70     		strb	r3, [r7, #3]
 763:../src/stm32f10x_adc.c ****   /* Check the parameters */
 764:../src/stm32f10x_adc.c ****   assert_param(IS_ADC_ALL_PERIPH(ADCx));
 765:../src/stm32f10x_adc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 766:../src/stm32f10x_adc.c ****   if (NewState != DISABLE)
 1269              		.loc 1 766 0
 1270 0648 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1271 064a 002B     		cmp	r3, #0
 1272 064c 06D0     		beq	.L49
 767:../src/stm32f10x_adc.c ****   {
 768:../src/stm32f10x_adc.c ****     /* Enable the selected ADC injected discontinuous mode */
 769:../src/stm32f10x_adc.c ****     ADCx->CR1 |= CR1_JDISCEN_Set;
 1273              		.loc 1 769 0
 1274 064e 7B68     		ldr	r3, [r7, #4]
 1275 0650 5B68     		ldr	r3, [r3, #4]
 1276 0652 43F48052 		orr	r2, r3, #4096
 1277 0656 7B68     		ldr	r3, [r7, #4]
 1278 0658 5A60     		str	r2, [r3, #4]
 1279 065a 05E0     		b	.L48
 1280              	.L49:
 770:../src/stm32f10x_adc.c ****   }
 771:../src/stm32f10x_adc.c ****   else
 772:../src/stm32f10x_adc.c ****   {
 773:../src/stm32f10x_adc.c ****     /* Disable the selected ADC injected discontinuous mode */
 774:../src/stm32f10x_adc.c ****     ADCx->CR1 &= CR1_JDISCEN_Reset;
 1281              		.loc 1 774 0
 1282 065c 7B68     		ldr	r3, [r7, #4]
 1283 065e 5B68     		ldr	r3, [r3, #4]
 1284 0660 23F48052 		bic	r2, r3, #4096
 1285 0664 7B68     		ldr	r3, [r7, #4]
 1286 0666 5A60     		str	r2, [r3, #4]
 1287              	.L48:
 775:../src/stm32f10x_adc.c ****   }
 776:../src/stm32f10x_adc.c **** }
 1288              		.loc 1 776 0
 1289 0668 07F10C07 		add	r7, r7, #12
 1290 066c BD46     		mov	sp, r7
 1291 066e 80BC     		pop	{r7}
 1292 0670 7047     		bx	lr
 1293              		.cfi_endproc
 1294              	.LFE48:
 1296 0672 00BF     		.align	2
 1297              		.global	ADC_ExternalTrigInjectedConvConfig
 1298              		.thumb
 1299              		.thumb_func
 1301              	ADC_ExternalTrigInjectedConvConfig:
 1302              	.LFB49:
 777:../src/stm32f10x_adc.c **** 
 778:../src/stm32f10x_adc.c **** /**
 779:../src/stm32f10x_adc.c ****   * @brief  Configures the ADCx external trigger for injected channels conversion.
 780:../src/stm32f10x_adc.c ****   * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
 781:../src/stm32f10x_adc.c ****   * @param  ADC_ExternalTrigInjecConv: specifies the ADC trigger to start injected conversion. 
 782:../src/stm32f10x_adc.c ****   *   This parameter can be one of the following values:
 783:../src/stm32f10x_adc.c ****   *     @arg ADC_ExternalTrigInjecConv_T1_TRGO: Timer1 TRGO event selected (for ADC1, ADC2 and ADC3
 784:../src/stm32f10x_adc.c ****   *     @arg ADC_ExternalTrigInjecConv_T1_CC4: Timer1 capture compare4 selected (for ADC1, ADC2 and
 785:../src/stm32f10x_adc.c ****   *     @arg ADC_ExternalTrigInjecConv_T2_TRGO: Timer2 TRGO event selected (for ADC1 and ADC2)
 786:../src/stm32f10x_adc.c ****   *     @arg ADC_ExternalTrigInjecConv_T2_CC1: Timer2 capture compare1 selected (for ADC1 and ADC2)
 787:../src/stm32f10x_adc.c ****   *     @arg ADC_ExternalTrigInjecConv_T3_CC4: Timer3 capture compare4 selected (for ADC1 and ADC2)
 788:../src/stm32f10x_adc.c ****   *     @arg ADC_ExternalTrigInjecConv_T4_TRGO: Timer4 TRGO event selected (for ADC1 and ADC2)
 789:../src/stm32f10x_adc.c ****   *     @arg ADC_ExternalTrigInjecConv_Ext_IT15_TIM8_CC4: External interrupt line 15 or Timer8
 790:../src/stm32f10x_adc.c ****   *                                                       capture compare4 event selected (for ADC1
 791:../src/stm32f10x_adc.c ****   *     @arg ADC_ExternalTrigInjecConv_T4_CC3: Timer4 capture compare3 selected (for ADC3 only)
 792:../src/stm32f10x_adc.c ****   *     @arg ADC_ExternalTrigInjecConv_T8_CC2: Timer8 capture compare2 selected (for ADC3 only)    
 793:../src/stm32f10x_adc.c ****   *     @arg ADC_ExternalTrigInjecConv_T8_CC4: Timer8 capture compare4 selected (for ADC3 only)
 794:../src/stm32f10x_adc.c ****   *     @arg ADC_ExternalTrigInjecConv_T5_TRGO: Timer5 TRGO event selected (for ADC3 only)         
 795:../src/stm32f10x_adc.c ****   *     @arg ADC_ExternalTrigInjecConv_T5_CC4: Timer5 capture compare4 selected (for ADC3 only)    
 796:../src/stm32f10x_adc.c ****   *     @arg ADC_ExternalTrigInjecConv_None: Injected conversion started by software and not
 797:../src/stm32f10x_adc.c ****   *                                          by external trigger (for ADC1, ADC2 and ADC3)
 798:../src/stm32f10x_adc.c ****   * @retval None
 799:../src/stm32f10x_adc.c ****   */
 800:../src/stm32f10x_adc.c **** void ADC_ExternalTrigInjectedConvConfig(ADC_TypeDef* ADCx, uint32_t ADC_ExternalTrigInjecConv)
 801:../src/stm32f10x_adc.c **** {
 1303              		.loc 1 801 0
 1304              		.cfi_startproc
 1305              		@ args = 0, pretend = 0, frame = 16
 1306              		@ frame_needed = 1, uses_anonymous_args = 0
 1307              		@ link register save eliminated.
 1308 0674 80B4     		push	{r7}
 1309              	.LCFI59:
 1310              		.cfi_def_cfa_offset 4
 1311              		.cfi_offset 7, -4
 1312 0676 85B0     		sub	sp, sp, #20
 1313              	.LCFI60:
 1314              		.cfi_def_cfa_offset 24
 1315 0678 00AF     		add	r7, sp, #0
 1316              	.LCFI61:
 1317              		.cfi_def_cfa_register 7
 1318 067a 7860     		str	r0, [r7, #4]
 1319 067c 3960     		str	r1, [r7, #0]
 802:../src/stm32f10x_adc.c ****   uint32_t tmpreg = 0;
 1320              		.loc 1 802 0
 1321 067e 4FF00003 		mov	r3, #0
 1322 0682 FB60     		str	r3, [r7, #12]
 803:../src/stm32f10x_adc.c ****   /* Check the parameters */
 804:../src/stm32f10x_adc.c ****   assert_param(IS_ADC_ALL_PERIPH(ADCx));
 805:../src/stm32f10x_adc.c ****   assert_param(IS_ADC_EXT_INJEC_TRIG(ADC_ExternalTrigInjecConv));
 806:../src/stm32f10x_adc.c ****   /* Get the old register value */
 807:../src/stm32f10x_adc.c ****   tmpreg = ADCx->CR2;
 1323              		.loc 1 807 0
 1324 0684 7B68     		ldr	r3, [r7, #4]
 1325 0686 9B68     		ldr	r3, [r3, #8]
 1326 0688 FB60     		str	r3, [r7, #12]
 808:../src/stm32f10x_adc.c ****   /* Clear the old external event selection for injected group */
 809:../src/stm32f10x_adc.c ****   tmpreg &= CR2_JEXTSEL_Reset;
 1327              		.loc 1 809 0
 1328 068a FB68     		ldr	r3, [r7, #12]
 1329 068c 23F4E043 		bic	r3, r3, #28672
 1330 0690 FB60     		str	r3, [r7, #12]
 810:../src/stm32f10x_adc.c ****   /* Set the external event selection for injected group */
 811:../src/stm32f10x_adc.c ****   tmpreg |= ADC_ExternalTrigInjecConv;
 1331              		.loc 1 811 0
 1332 0692 FA68     		ldr	r2, [r7, #12]
 1333 0694 3B68     		ldr	r3, [r7, #0]
 1334 0696 1343     		orrs	r3, r3, r2
 1335 0698 FB60     		str	r3, [r7, #12]
 812:../src/stm32f10x_adc.c ****   /* Store the new register value */
 813:../src/stm32f10x_adc.c ****   ADCx->CR2 = tmpreg;
 1336              		.loc 1 813 0
 1337 069a 7B68     		ldr	r3, [r7, #4]
 1338 069c FA68     		ldr	r2, [r7, #12]
 1339 069e 9A60     		str	r2, [r3, #8]
 814:../src/stm32f10x_adc.c **** }
 1340              		.loc 1 814 0
 1341 06a0 07F11407 		add	r7, r7, #20
 1342 06a4 BD46     		mov	sp, r7
 1343 06a6 80BC     		pop	{r7}
 1344 06a8 7047     		bx	lr
 1345              		.cfi_endproc
 1346              	.LFE49:
 1348 06aa 00BF     		.align	2
 1349              		.global	ADC_ExternalTrigInjectedConvCmd
 1350              		.thumb
 1351              		.thumb_func
 1353              	ADC_ExternalTrigInjectedConvCmd:
 1354              	.LFB50:
 815:../src/stm32f10x_adc.c **** 
 816:../src/stm32f10x_adc.c **** /**
 817:../src/stm32f10x_adc.c ****   * @brief  Enables or disables the ADCx injected channels conversion through
 818:../src/stm32f10x_adc.c ****   *         external trigger
 819:../src/stm32f10x_adc.c ****   * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
 820:../src/stm32f10x_adc.c ****   * @param  NewState: new state of the selected ADC external trigger start of
 821:../src/stm32f10x_adc.c ****   *         injected conversion.
 822:../src/stm32f10x_adc.c ****   *   This parameter can be: ENABLE or DISABLE.
 823:../src/stm32f10x_adc.c ****   * @retval None
 824:../src/stm32f10x_adc.c ****   */
 825:../src/stm32f10x_adc.c **** void ADC_ExternalTrigInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
 826:../src/stm32f10x_adc.c **** {
 1355              		.loc 1 826 0
 1356              		.cfi_startproc
 1357              		@ args = 0, pretend = 0, frame = 8
 1358              		@ frame_needed = 1, uses_anonymous_args = 0
 1359              		@ link register save eliminated.
 1360 06ac 80B4     		push	{r7}
 1361              	.LCFI62:
 1362              		.cfi_def_cfa_offset 4
 1363              		.cfi_offset 7, -4
 1364 06ae 83B0     		sub	sp, sp, #12
 1365              	.LCFI63:
 1366              		.cfi_def_cfa_offset 16
 1367 06b0 00AF     		add	r7, sp, #0
 1368              	.LCFI64:
 1369              		.cfi_def_cfa_register 7
 1370 06b2 7860     		str	r0, [r7, #4]
 1371 06b4 0B46     		mov	r3, r1
 1372 06b6 FB70     		strb	r3, [r7, #3]
 827:../src/stm32f10x_adc.c ****   /* Check the parameters */
 828:../src/stm32f10x_adc.c ****   assert_param(IS_ADC_ALL_PERIPH(ADCx));
 829:../src/stm32f10x_adc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 830:../src/stm32f10x_adc.c ****   if (NewState != DISABLE)
 1373              		.loc 1 830 0
 1374 06b8 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1375 06ba 002B     		cmp	r3, #0
 1376 06bc 06D0     		beq	.L53
 831:../src/stm32f10x_adc.c ****   {
 832:../src/stm32f10x_adc.c ****     /* Enable the selected ADC external event selection for injected group */
 833:../src/stm32f10x_adc.c ****     ADCx->CR2 |= CR2_JEXTTRIG_Set;
 1377              		.loc 1 833 0
 1378 06be 7B68     		ldr	r3, [r7, #4]
 1379 06c0 9B68     		ldr	r3, [r3, #8]
 1380 06c2 43F40042 		orr	r2, r3, #32768
 1381 06c6 7B68     		ldr	r3, [r7, #4]
 1382 06c8 9A60     		str	r2, [r3, #8]
 1383 06ca 05E0     		b	.L52
 1384              	.L53:
 834:../src/stm32f10x_adc.c ****   }
 835:../src/stm32f10x_adc.c ****   else
 836:../src/stm32f10x_adc.c ****   {
 837:../src/stm32f10x_adc.c ****     /* Disable the selected ADC external event selection for injected group */
 838:../src/stm32f10x_adc.c ****     ADCx->CR2 &= CR2_JEXTTRIG_Reset;
 1385              		.loc 1 838 0
 1386 06cc 7B68     		ldr	r3, [r7, #4]
 1387 06ce 9B68     		ldr	r3, [r3, #8]
 1388 06d0 23F40042 		bic	r2, r3, #32768
 1389 06d4 7B68     		ldr	r3, [r7, #4]
 1390 06d6 9A60     		str	r2, [r3, #8]
 1391              	.L52:
 839:../src/stm32f10x_adc.c ****   }
 840:../src/stm32f10x_adc.c **** }
 1392              		.loc 1 840 0
 1393 06d8 07F10C07 		add	r7, r7, #12
 1394 06dc BD46     		mov	sp, r7
 1395 06de 80BC     		pop	{r7}
 1396 06e0 7047     		bx	lr
 1397              		.cfi_endproc
 1398              	.LFE50:
 1400 06e2 00BF     		.align	2
 1401              		.global	ADC_SoftwareStartInjectedConvCmd
 1402              		.thumb
 1403              		.thumb_func
 1405              	ADC_SoftwareStartInjectedConvCmd:
 1406              	.LFB51:
 841:../src/stm32f10x_adc.c **** 
 842:../src/stm32f10x_adc.c **** /**
 843:../src/stm32f10x_adc.c ****   * @brief  Enables or disables the selected ADC start of the injected 
 844:../src/stm32f10x_adc.c ****   *         channels conversion.
 845:../src/stm32f10x_adc.c ****   * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
 846:../src/stm32f10x_adc.c ****   * @param  NewState: new state of the selected ADC software start injected conversion.
 847:../src/stm32f10x_adc.c ****   *   This parameter can be: ENABLE or DISABLE.
 848:../src/stm32f10x_adc.c ****   * @retval None
 849:../src/stm32f10x_adc.c ****   */
 850:../src/stm32f10x_adc.c **** void ADC_SoftwareStartInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
 851:../src/stm32f10x_adc.c **** {
 1407              		.loc 1 851 0
 1408              		.cfi_startproc
 1409              		@ args = 0, pretend = 0, frame = 8
 1410              		@ frame_needed = 1, uses_anonymous_args = 0
 1411              		@ link register save eliminated.
 1412 06e4 80B4     		push	{r7}
 1413              	.LCFI65:
 1414              		.cfi_def_cfa_offset 4
 1415              		.cfi_offset 7, -4
 1416 06e6 83B0     		sub	sp, sp, #12
 1417              	.LCFI66:
 1418              		.cfi_def_cfa_offset 16
 1419 06e8 00AF     		add	r7, sp, #0
 1420              	.LCFI67:
 1421              		.cfi_def_cfa_register 7
 1422 06ea 7860     		str	r0, [r7, #4]
 1423 06ec 0B46     		mov	r3, r1
 1424 06ee FB70     		strb	r3, [r7, #3]
 852:../src/stm32f10x_adc.c ****   /* Check the parameters */
 853:../src/stm32f10x_adc.c ****   assert_param(IS_ADC_ALL_PERIPH(ADCx));
 854:../src/stm32f10x_adc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 855:../src/stm32f10x_adc.c ****   if (NewState != DISABLE)
 1425              		.loc 1 855 0
 1426 06f0 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1427 06f2 002B     		cmp	r3, #0
 1428 06f4 06D0     		beq	.L56
 856:../src/stm32f10x_adc.c ****   {
 857:../src/stm32f10x_adc.c ****     /* Enable the selected ADC conversion for injected group on external event and start the select
 858:../src/stm32f10x_adc.c ****        ADC injected conversion */
 859:../src/stm32f10x_adc.c ****     ADCx->CR2 |= CR2_JEXTTRIG_JSWSTART_Set;
 1429              		.loc 1 859 0
 1430 06f6 7B68     		ldr	r3, [r7, #4]
 1431 06f8 9B68     		ldr	r3, [r3, #8]
 1432 06fa 43F40212 		orr	r2, r3, #2129920
 1433 06fe 7B68     		ldr	r3, [r7, #4]
 1434 0700 9A60     		str	r2, [r3, #8]
 1435 0702 05E0     		b	.L55
 1436              	.L56:
 860:../src/stm32f10x_adc.c ****   }
 861:../src/stm32f10x_adc.c ****   else
 862:../src/stm32f10x_adc.c ****   {
 863:../src/stm32f10x_adc.c ****     /* Disable the selected ADC conversion on external event for injected group and stop the select
 864:../src/stm32f10x_adc.c ****        ADC injected conversion */
 865:../src/stm32f10x_adc.c ****     ADCx->CR2 &= CR2_JEXTTRIG_JSWSTART_Reset;
 1437              		.loc 1 865 0
 1438 0704 7B68     		ldr	r3, [r7, #4]
 1439 0706 9B68     		ldr	r3, [r3, #8]
 1440 0708 23F40212 		bic	r2, r3, #2129920
 1441 070c 7B68     		ldr	r3, [r7, #4]
 1442 070e 9A60     		str	r2, [r3, #8]
 1443              	.L55:
 866:../src/stm32f10x_adc.c ****   }
 867:../src/stm32f10x_adc.c **** }
 1444              		.loc 1 867 0
 1445 0710 07F10C07 		add	r7, r7, #12
 1446 0714 BD46     		mov	sp, r7
 1447 0716 80BC     		pop	{r7}
 1448 0718 7047     		bx	lr
 1449              		.cfi_endproc
 1450              	.LFE51:
 1452 071a 00BF     		.align	2
 1453              		.global	ADC_GetSoftwareStartInjectedConvCmdStatus
 1454              		.thumb
 1455              		.thumb_func
 1457              	ADC_GetSoftwareStartInjectedConvCmdStatus:
 1458              	.LFB52:
 868:../src/stm32f10x_adc.c **** 
 869:../src/stm32f10x_adc.c **** /**
 870:../src/stm32f10x_adc.c ****   * @brief  Gets the selected ADC Software start injected conversion Status.
 871:../src/stm32f10x_adc.c ****   * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
 872:../src/stm32f10x_adc.c ****   * @retval The new state of ADC software start injected conversion (SET or RESET).
 873:../src/stm32f10x_adc.c ****   */
 874:../src/stm32f10x_adc.c **** FlagStatus ADC_GetSoftwareStartInjectedConvCmdStatus(ADC_TypeDef* ADCx)
 875:../src/stm32f10x_adc.c **** {
 1459              		.loc 1 875 0
 1460              		.cfi_startproc
 1461              		@ args = 0, pretend = 0, frame = 16
 1462              		@ frame_needed = 1, uses_anonymous_args = 0
 1463              		@ link register save eliminated.
 1464 071c 80B4     		push	{r7}
 1465              	.LCFI68:
 1466              		.cfi_def_cfa_offset 4
 1467              		.cfi_offset 7, -4
 1468 071e 85B0     		sub	sp, sp, #20
 1469              	.LCFI69:
 1470              		.cfi_def_cfa_offset 24
 1471 0720 00AF     		add	r7, sp, #0
 1472              	.LCFI70:
 1473              		.cfi_def_cfa_register 7
 1474 0722 7860     		str	r0, [r7, #4]
 876:../src/stm32f10x_adc.c ****   FlagStatus bitstatus = RESET;
 1475              		.loc 1 876 0
 1476 0724 4FF00003 		mov	r3, #0
 1477 0728 FB73     		strb	r3, [r7, #15]
 877:../src/stm32f10x_adc.c ****   /* Check the parameters */
 878:../src/stm32f10x_adc.c ****   assert_param(IS_ADC_ALL_PERIPH(ADCx));
 879:../src/stm32f10x_adc.c ****   /* Check the status of JSWSTART bit */
 880:../src/stm32f10x_adc.c ****   if ((ADCx->CR2 & CR2_JSWSTART_Set) != (uint32_t)RESET)
 1478              		.loc 1 880 0
 1479 072a 7B68     		ldr	r3, [r7, #4]
 1480 072c 9B68     		ldr	r3, [r3, #8]
 1481 072e 03F40013 		and	r3, r3, #2097152
 1482 0732 002B     		cmp	r3, #0
 1483 0734 03D0     		beq	.L59
 881:../src/stm32f10x_adc.c ****   {
 882:../src/stm32f10x_adc.c ****     /* JSWSTART bit is set */
 883:../src/stm32f10x_adc.c ****     bitstatus = SET;
 1484              		.loc 1 883 0
 1485 0736 4FF00103 		mov	r3, #1
 1486 073a FB73     		strb	r3, [r7, #15]
 1487 073c 02E0     		b	.L60
 1488              	.L59:
 884:../src/stm32f10x_adc.c ****   }
 885:../src/stm32f10x_adc.c ****   else
 886:../src/stm32f10x_adc.c ****   {
 887:../src/stm32f10x_adc.c ****     /* JSWSTART bit is reset */
 888:../src/stm32f10x_adc.c ****     bitstatus = RESET;
 1489              		.loc 1 888 0
 1490 073e 4FF00003 		mov	r3, #0
 1491 0742 FB73     		strb	r3, [r7, #15]
 1492              	.L60:
 889:../src/stm32f10x_adc.c ****   }
 890:../src/stm32f10x_adc.c ****   /* Return the JSWSTART bit status */
 891:../src/stm32f10x_adc.c ****   return  bitstatus;
 1493              		.loc 1 891 0
 1494 0744 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 892:../src/stm32f10x_adc.c **** }
 1495              		.loc 1 892 0
 1496 0746 1846     		mov	r0, r3
 1497 0748 07F11407 		add	r7, r7, #20
 1498 074c BD46     		mov	sp, r7
 1499 074e 80BC     		pop	{r7}
 1500 0750 7047     		bx	lr
 1501              		.cfi_endproc
 1502              	.LFE52:
 1504 0752 00BF     		.align	2
 1505              		.global	ADC_InjectedChannelConfig
 1506              		.thumb
 1507              		.thumb_func
 1509              	ADC_InjectedChannelConfig:
 1510              	.LFB53:
 893:../src/stm32f10x_adc.c **** 
 894:../src/stm32f10x_adc.c **** /**
 895:../src/stm32f10x_adc.c ****   * @brief  Configures for the selected ADC injected channel its corresponding
 896:../src/stm32f10x_adc.c ****   *         rank in the sequencer and its sample time.
 897:../src/stm32f10x_adc.c ****   * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
 898:../src/stm32f10x_adc.c ****   * @param  ADC_Channel: the ADC channel to configure. 
 899:../src/stm32f10x_adc.c ****   *   This parameter can be one of the following values:
 900:../src/stm32f10x_adc.c ****   *     @arg ADC_Channel_0: ADC Channel0 selected
 901:../src/stm32f10x_adc.c ****   *     @arg ADC_Channel_1: ADC Channel1 selected
 902:../src/stm32f10x_adc.c ****   *     @arg ADC_Channel_2: ADC Channel2 selected
 903:../src/stm32f10x_adc.c ****   *     @arg ADC_Channel_3: ADC Channel3 selected
 904:../src/stm32f10x_adc.c ****   *     @arg ADC_Channel_4: ADC Channel4 selected
 905:../src/stm32f10x_adc.c ****   *     @arg ADC_Channel_5: ADC Channel5 selected
 906:../src/stm32f10x_adc.c ****   *     @arg ADC_Channel_6: ADC Channel6 selected
 907:../src/stm32f10x_adc.c ****   *     @arg ADC_Channel_7: ADC Channel7 selected
 908:../src/stm32f10x_adc.c ****   *     @arg ADC_Channel_8: ADC Channel8 selected
 909:../src/stm32f10x_adc.c ****   *     @arg ADC_Channel_9: ADC Channel9 selected
 910:../src/stm32f10x_adc.c ****   *     @arg ADC_Channel_10: ADC Channel10 selected
 911:../src/stm32f10x_adc.c ****   *     @arg ADC_Channel_11: ADC Channel11 selected
 912:../src/stm32f10x_adc.c ****   *     @arg ADC_Channel_12: ADC Channel12 selected
 913:../src/stm32f10x_adc.c ****   *     @arg ADC_Channel_13: ADC Channel13 selected
 914:../src/stm32f10x_adc.c ****   *     @arg ADC_Channel_14: ADC Channel14 selected
 915:../src/stm32f10x_adc.c ****   *     @arg ADC_Channel_15: ADC Channel15 selected
 916:../src/stm32f10x_adc.c ****   *     @arg ADC_Channel_16: ADC Channel16 selected
 917:../src/stm32f10x_adc.c ****   *     @arg ADC_Channel_17: ADC Channel17 selected
 918:../src/stm32f10x_adc.c ****   * @param  Rank: The rank in the injected group sequencer. This parameter must be between 1 and 4.
 919:../src/stm32f10x_adc.c ****   * @param  ADC_SampleTime: The sample time value to be set for the selected channel. 
 920:../src/stm32f10x_adc.c ****   *   This parameter can be one of the following values:
 921:../src/stm32f10x_adc.c ****   *     @arg ADC_SampleTime_1Cycles5: Sample time equal to 1.5 cycles
 922:../src/stm32f10x_adc.c ****   *     @arg ADC_SampleTime_7Cycles5: Sample time equal to 7.5 cycles
 923:../src/stm32f10x_adc.c ****   *     @arg ADC_SampleTime_13Cycles5: Sample time equal to 13.5 cycles
 924:../src/stm32f10x_adc.c ****   *     @arg ADC_SampleTime_28Cycles5: Sample time equal to 28.5 cycles	
 925:../src/stm32f10x_adc.c ****   *     @arg ADC_SampleTime_41Cycles5: Sample time equal to 41.5 cycles	
 926:../src/stm32f10x_adc.c ****   *     @arg ADC_SampleTime_55Cycles5: Sample time equal to 55.5 cycles	
 927:../src/stm32f10x_adc.c ****   *     @arg ADC_SampleTime_71Cycles5: Sample time equal to 71.5 cycles	
 928:../src/stm32f10x_adc.c ****   *     @arg ADC_SampleTime_239Cycles5: Sample time equal to 239.5 cycles	
 929:../src/stm32f10x_adc.c ****   * @retval None
 930:../src/stm32f10x_adc.c ****   */
 931:../src/stm32f10x_adc.c **** void ADC_InjectedChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_Sa
 932:../src/stm32f10x_adc.c **** {
 1511              		.loc 1 932 0
 1512              		.cfi_startproc
 1513              		@ args = 0, pretend = 0, frame = 24
 1514              		@ frame_needed = 1, uses_anonymous_args = 0
 1515              		@ link register save eliminated.
 1516 0754 80B4     		push	{r7}
 1517              	.LCFI71:
 1518              		.cfi_def_cfa_offset 4
 1519              		.cfi_offset 7, -4
 1520 0756 87B0     		sub	sp, sp, #28
 1521              	.LCFI72:
 1522              		.cfi_def_cfa_offset 32
 1523 0758 00AF     		add	r7, sp, #0
 1524              	.LCFI73:
 1525              		.cfi_def_cfa_register 7
 1526 075a 7860     		str	r0, [r7, #4]
 1527 075c F970     		strb	r1, [r7, #3]
 1528 075e BA70     		strb	r2, [r7, #2]
 1529 0760 7B70     		strb	r3, [r7, #1]
 933:../src/stm32f10x_adc.c ****   uint32_t tmpreg1 = 0, tmpreg2 = 0, tmpreg3 = 0;
 1530              		.loc 1 933 0
 1531 0762 4FF00003 		mov	r3, #0
 1532 0766 7B61     		str	r3, [r7, #20]
 1533 0768 4FF00003 		mov	r3, #0
 1534 076c 3B61     		str	r3, [r7, #16]
 1535 076e 4FF00003 		mov	r3, #0
 1536 0772 FB60     		str	r3, [r7, #12]
 934:../src/stm32f10x_adc.c ****   /* Check the parameters */
 935:../src/stm32f10x_adc.c ****   assert_param(IS_ADC_ALL_PERIPH(ADCx));
 936:../src/stm32f10x_adc.c ****   assert_param(IS_ADC_CHANNEL(ADC_Channel));
 937:../src/stm32f10x_adc.c ****   assert_param(IS_ADC_INJECTED_RANK(Rank));
 938:../src/stm32f10x_adc.c ****   assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
 939:../src/stm32f10x_adc.c ****   /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
 940:../src/stm32f10x_adc.c ****   if (ADC_Channel > ADC_Channel_9)
 1537              		.loc 1 940 0
 1538 0774 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1539 0776 092B     		cmp	r3, #9
 1540 0778 27D9     		bls	.L62
 941:../src/stm32f10x_adc.c ****   {
 942:../src/stm32f10x_adc.c ****     /* Get the old register value */
 943:../src/stm32f10x_adc.c ****     tmpreg1 = ADCx->SMPR1;
 1541              		.loc 1 943 0
 1542 077a 7B68     		ldr	r3, [r7, #4]
 1543 077c DB68     		ldr	r3, [r3, #12]
 1544 077e 7B61     		str	r3, [r7, #20]
 944:../src/stm32f10x_adc.c ****     /* Calculate the mask to clear */
 945:../src/stm32f10x_adc.c ****     tmpreg2 = SMPR1_SMP_Set << (3*(ADC_Channel - 10));
 1545              		.loc 1 945 0
 1546 0780 FA78     		ldrb	r2, [r7, #3]	@ zero_extendqisi2
 1547 0782 1346     		mov	r3, r2
 1548 0784 4FEA4303 		lsl	r3, r3, #1
 1549 0788 9B18     		adds	r3, r3, r2
 1550 078a A3F11E03 		sub	r3, r3, #30
 1551 078e 4FF00702 		mov	r2, #7
 1552 0792 02FA03F3 		lsl	r3, r2, r3
 1553 0796 3B61     		str	r3, [r7, #16]
 946:../src/stm32f10x_adc.c ****     /* Clear the old channel sample time */
 947:../src/stm32f10x_adc.c ****     tmpreg1 &= ~tmpreg2;
 1554              		.loc 1 947 0
 1555 0798 3B69     		ldr	r3, [r7, #16]
 1556 079a 6FEA0303 		mvn	r3, r3
 1557 079e 7A69     		ldr	r2, [r7, #20]
 1558 07a0 1340     		ands	r3, r3, r2
 1559 07a2 7B61     		str	r3, [r7, #20]
 948:../src/stm32f10x_adc.c ****     /* Calculate the mask to set */
 949:../src/stm32f10x_adc.c ****     tmpreg2 = (uint32_t)ADC_SampleTime << (3*(ADC_Channel - 10));
 1560              		.loc 1 949 0
 1561 07a4 7978     		ldrb	r1, [r7, #1]	@ zero_extendqisi2
 1562 07a6 FA78     		ldrb	r2, [r7, #3]	@ zero_extendqisi2
 1563 07a8 1346     		mov	r3, r2
 1564 07aa 4FEA4303 		lsl	r3, r3, #1
 1565 07ae 9B18     		adds	r3, r3, r2
 1566 07b0 A3F11E03 		sub	r3, r3, #30
 1567 07b4 01FA03F3 		lsl	r3, r1, r3
 1568 07b8 3B61     		str	r3, [r7, #16]
 950:../src/stm32f10x_adc.c ****     /* Set the new channel sample time */
 951:../src/stm32f10x_adc.c ****     tmpreg1 |= tmpreg2;
 1569              		.loc 1 951 0
 1570 07ba 7A69     		ldr	r2, [r7, #20]
 1571 07bc 3B69     		ldr	r3, [r7, #16]
 1572 07be 1343     		orrs	r3, r3, r2
 1573 07c0 7B61     		str	r3, [r7, #20]
 952:../src/stm32f10x_adc.c ****     /* Store the new register value */
 953:../src/stm32f10x_adc.c ****     ADCx->SMPR1 = tmpreg1;
 1574              		.loc 1 953 0
 1575 07c2 7B68     		ldr	r3, [r7, #4]
 1576 07c4 7A69     		ldr	r2, [r7, #20]
 1577 07c6 DA60     		str	r2, [r3, #12]
 1578 07c8 22E0     		b	.L63
 1579              	.L62:
 954:../src/stm32f10x_adc.c ****   }
 955:../src/stm32f10x_adc.c ****   else /* ADC_Channel include in ADC_Channel_[0..9] */
 956:../src/stm32f10x_adc.c ****   {
 957:../src/stm32f10x_adc.c ****     /* Get the old register value */
 958:../src/stm32f10x_adc.c ****     tmpreg1 = ADCx->SMPR2;
 1580              		.loc 1 958 0
 1581 07ca 7B68     		ldr	r3, [r7, #4]
 1582 07cc 1B69     		ldr	r3, [r3, #16]
 1583 07ce 7B61     		str	r3, [r7, #20]
 959:../src/stm32f10x_adc.c ****     /* Calculate the mask to clear */
 960:../src/stm32f10x_adc.c ****     tmpreg2 = SMPR2_SMP_Set << (3 * ADC_Channel);
 1584              		.loc 1 960 0
 1585 07d0 FA78     		ldrb	r2, [r7, #3]	@ zero_extendqisi2
 1586 07d2 1346     		mov	r3, r2
 1587 07d4 4FEA4303 		lsl	r3, r3, #1
 1588 07d8 9B18     		adds	r3, r3, r2
 1589 07da 4FF00702 		mov	r2, #7
 1590 07de 02FA03F3 		lsl	r3, r2, r3
 1591 07e2 3B61     		str	r3, [r7, #16]
 961:../src/stm32f10x_adc.c ****     /* Clear the old channel sample time */
 962:../src/stm32f10x_adc.c ****     tmpreg1 &= ~tmpreg2;
 1592              		.loc 1 962 0
 1593 07e4 3B69     		ldr	r3, [r7, #16]
 1594 07e6 6FEA0303 		mvn	r3, r3
 1595 07ea 7A69     		ldr	r2, [r7, #20]
 1596 07ec 1340     		ands	r3, r3, r2
 1597 07ee 7B61     		str	r3, [r7, #20]
 963:../src/stm32f10x_adc.c ****     /* Calculate the mask to set */
 964:../src/stm32f10x_adc.c ****     tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
 1598              		.loc 1 964 0
 1599 07f0 7978     		ldrb	r1, [r7, #1]	@ zero_extendqisi2
 1600 07f2 FA78     		ldrb	r2, [r7, #3]	@ zero_extendqisi2
 1601 07f4 1346     		mov	r3, r2
 1602 07f6 4FEA4303 		lsl	r3, r3, #1
 1603 07fa 9B18     		adds	r3, r3, r2
 1604 07fc 01FA03F3 		lsl	r3, r1, r3
 1605 0800 3B61     		str	r3, [r7, #16]
 965:../src/stm32f10x_adc.c ****     /* Set the new channel sample time */
 966:../src/stm32f10x_adc.c ****     tmpreg1 |= tmpreg2;
 1606              		.loc 1 966 0
 1607 0802 7A69     		ldr	r2, [r7, #20]
 1608 0804 3B69     		ldr	r3, [r7, #16]
 1609 0806 1343     		orrs	r3, r3, r2
 1610 0808 7B61     		str	r3, [r7, #20]
 967:../src/stm32f10x_adc.c ****     /* Store the new register value */
 968:../src/stm32f10x_adc.c ****     ADCx->SMPR2 = tmpreg1;
 1611              		.loc 1 968 0
 1612 080a 7B68     		ldr	r3, [r7, #4]
 1613 080c 7A69     		ldr	r2, [r7, #20]
 1614 080e 1A61     		str	r2, [r3, #16]
 1615              	.L63:
 969:../src/stm32f10x_adc.c ****   }
 970:../src/stm32f10x_adc.c ****   /* Rank configuration */
 971:../src/stm32f10x_adc.c ****   /* Get the old register value */
 972:../src/stm32f10x_adc.c ****   tmpreg1 = ADCx->JSQR;
 1616              		.loc 1 972 0
 1617 0810 7B68     		ldr	r3, [r7, #4]
 1618 0812 9B6B     		ldr	r3, [r3, #56]
 1619 0814 7B61     		str	r3, [r7, #20]
 973:../src/stm32f10x_adc.c ****   /* Get JL value: Number = JL+1 */
 974:../src/stm32f10x_adc.c ****   tmpreg3 =  (tmpreg1 & JSQR_JL_Set)>> 20;
 1620              		.loc 1 974 0
 1621 0816 7B69     		ldr	r3, [r7, #20]
 1622 0818 03F44013 		and	r3, r3, #3145728
 1623 081c 4FEA1353 		lsr	r3, r3, #20
 1624 0820 FB60     		str	r3, [r7, #12]
 975:../src/stm32f10x_adc.c ****   /* Calculate the mask to clear: ((Rank-1)+(4-JL-1)) */
 976:../src/stm32f10x_adc.c ****   tmpreg2 = JSQR_JSQ_Set << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1)));
 1625              		.loc 1 976 0
 1626 0822 FB68     		ldr	r3, [r7, #12]
 1627 0824 DBB2     		uxtb	r3, r3
 1628 0826 6FEA0303 		mvn	r3, r3
 1629 082a DAB2     		uxtb	r2, r3
 1630 082c BB78     		ldrb	r3, [r7, #2]
 1631 082e D318     		adds	r3, r2, r3
 1632 0830 DBB2     		uxtb	r3, r3
 1633 0832 03F10303 		add	r3, r3, #3
 1634 0836 DBB2     		uxtb	r3, r3
 1635 0838 1A46     		mov	r2, r3
 1636 083a 1346     		mov	r3, r2
 1637 083c 4FEA8303 		lsl	r3, r3, #2
 1638 0840 9B18     		adds	r3, r3, r2
 1639 0842 4FF01F02 		mov	r2, #31
 1640 0846 02FA03F3 		lsl	r3, r2, r3
 1641 084a 3B61     		str	r3, [r7, #16]
 977:../src/stm32f10x_adc.c ****   /* Clear the old JSQx bits for the selected rank */
 978:../src/stm32f10x_adc.c ****   tmpreg1 &= ~tmpreg2;
 1642              		.loc 1 978 0
 1643 084c 3B69     		ldr	r3, [r7, #16]
 1644 084e 6FEA0303 		mvn	r3, r3
 1645 0852 7A69     		ldr	r2, [r7, #20]
 1646 0854 1340     		ands	r3, r3, r2
 1647 0856 7B61     		str	r3, [r7, #20]
 979:../src/stm32f10x_adc.c ****   /* Calculate the mask to set: ((Rank-1)+(4-JL-1)) */
 980:../src/stm32f10x_adc.c ****   tmpreg2 = (uint32_t)ADC_Channel << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1)));
 1648              		.loc 1 980 0
 1649 0858 F978     		ldrb	r1, [r7, #3]	@ zero_extendqisi2
 1650 085a FB68     		ldr	r3, [r7, #12]
 1651 085c DBB2     		uxtb	r3, r3
 1652 085e 6FEA0303 		mvn	r3, r3
 1653 0862 DAB2     		uxtb	r2, r3
 1654 0864 BB78     		ldrb	r3, [r7, #2]
 1655 0866 D318     		adds	r3, r2, r3
 1656 0868 DBB2     		uxtb	r3, r3
 1657 086a 03F10303 		add	r3, r3, #3
 1658 086e DBB2     		uxtb	r3, r3
 1659 0870 1A46     		mov	r2, r3
 1660 0872 1346     		mov	r3, r2
 1661 0874 4FEA8303 		lsl	r3, r3, #2
 1662 0878 9B18     		adds	r3, r3, r2
 1663 087a 01FA03F3 		lsl	r3, r1, r3
 1664 087e 3B61     		str	r3, [r7, #16]
 981:../src/stm32f10x_adc.c ****   /* Set the JSQx bits for the selected rank */
 982:../src/stm32f10x_adc.c ****   tmpreg1 |= tmpreg2;
 1665              		.loc 1 982 0
 1666 0880 7A69     		ldr	r2, [r7, #20]
 1667 0882 3B69     		ldr	r3, [r7, #16]
 1668 0884 1343     		orrs	r3, r3, r2
 1669 0886 7B61     		str	r3, [r7, #20]
 983:../src/stm32f10x_adc.c ****   /* Store the new register value */
 984:../src/stm32f10x_adc.c ****   ADCx->JSQR = tmpreg1;
 1670              		.loc 1 984 0
 1671 0888 7B68     		ldr	r3, [r7, #4]
 1672 088a 7A69     		ldr	r2, [r7, #20]
 1673 088c 9A63     		str	r2, [r3, #56]
 985:../src/stm32f10x_adc.c **** }
 1674              		.loc 1 985 0
 1675 088e 07F11C07 		add	r7, r7, #28
 1676 0892 BD46     		mov	sp, r7
 1677 0894 80BC     		pop	{r7}
 1678 0896 7047     		bx	lr
 1679              		.cfi_endproc
 1680              	.LFE53:
 1682              		.align	2
 1683              		.global	ADC_InjectedSequencerLengthConfig
 1684              		.thumb
 1685              		.thumb_func
 1687              	ADC_InjectedSequencerLengthConfig:
 1688              	.LFB54:
 986:../src/stm32f10x_adc.c **** 
 987:../src/stm32f10x_adc.c **** /**
 988:../src/stm32f10x_adc.c ****   * @brief  Configures the sequencer length for injected channels
 989:../src/stm32f10x_adc.c ****   * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
 990:../src/stm32f10x_adc.c ****   * @param  Length: The sequencer length. 
 991:../src/stm32f10x_adc.c ****   *   This parameter must be a number between 1 to 4.
 992:../src/stm32f10x_adc.c ****   * @retval None
 993:../src/stm32f10x_adc.c ****   */
 994:../src/stm32f10x_adc.c **** void ADC_InjectedSequencerLengthConfig(ADC_TypeDef* ADCx, uint8_t Length)
 995:../src/stm32f10x_adc.c **** {
 1689              		.loc 1 995 0
 1690              		.cfi_startproc
 1691              		@ args = 0, pretend = 0, frame = 16
 1692              		@ frame_needed = 1, uses_anonymous_args = 0
 1693              		@ link register save eliminated.
 1694 0898 80B4     		push	{r7}
 1695              	.LCFI74:
 1696              		.cfi_def_cfa_offset 4
 1697              		.cfi_offset 7, -4
 1698 089a 85B0     		sub	sp, sp, #20
 1699              	.LCFI75:
 1700              		.cfi_def_cfa_offset 24
 1701 089c 00AF     		add	r7, sp, #0
 1702              	.LCFI76:
 1703              		.cfi_def_cfa_register 7
 1704 089e 7860     		str	r0, [r7, #4]
 1705 08a0 0B46     		mov	r3, r1
 1706 08a2 FB70     		strb	r3, [r7, #3]
 996:../src/stm32f10x_adc.c ****   uint32_t tmpreg1 = 0;
 1707              		.loc 1 996 0
 1708 08a4 4FF00003 		mov	r3, #0
 1709 08a8 FB60     		str	r3, [r7, #12]
 997:../src/stm32f10x_adc.c ****   uint32_t tmpreg2 = 0;
 1710              		.loc 1 997 0
 1711 08aa 4FF00003 		mov	r3, #0
 1712 08ae BB60     		str	r3, [r7, #8]
 998:../src/stm32f10x_adc.c ****   /* Check the parameters */
 999:../src/stm32f10x_adc.c ****   assert_param(IS_ADC_ALL_PERIPH(ADCx));
1000:../src/stm32f10x_adc.c ****   assert_param(IS_ADC_INJECTED_LENGTH(Length));
1001:../src/stm32f10x_adc.c ****   
1002:../src/stm32f10x_adc.c ****   /* Get the old register value */
1003:../src/stm32f10x_adc.c ****   tmpreg1 = ADCx->JSQR;
 1713              		.loc 1 1003 0
 1714 08b0 7B68     		ldr	r3, [r7, #4]
 1715 08b2 9B6B     		ldr	r3, [r3, #56]
 1716 08b4 FB60     		str	r3, [r7, #12]
1004:../src/stm32f10x_adc.c ****   /* Clear the old injected sequnence lenght JL bits */
1005:../src/stm32f10x_adc.c ****   tmpreg1 &= JSQR_JL_Reset;
 1717              		.loc 1 1005 0
 1718 08b6 FB68     		ldr	r3, [r7, #12]
 1719 08b8 23F44013 		bic	r3, r3, #3145728
 1720 08bc FB60     		str	r3, [r7, #12]
1006:../src/stm32f10x_adc.c ****   /* Set the injected sequnence lenght JL bits */
1007:../src/stm32f10x_adc.c ****   tmpreg2 = Length - 1; 
 1721              		.loc 1 1007 0
 1722 08be FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1723 08c0 03F1FF33 		add	r3, r3, #-1
 1724 08c4 BB60     		str	r3, [r7, #8]
1008:../src/stm32f10x_adc.c ****   tmpreg1 |= tmpreg2 << 20;
 1725              		.loc 1 1008 0
 1726 08c6 BB68     		ldr	r3, [r7, #8]
 1727 08c8 4FEA0353 		lsl	r3, r3, #20
 1728 08cc FA68     		ldr	r2, [r7, #12]
 1729 08ce 1343     		orrs	r3, r3, r2
 1730 08d0 FB60     		str	r3, [r7, #12]
1009:../src/stm32f10x_adc.c ****   /* Store the new register value */
1010:../src/stm32f10x_adc.c ****   ADCx->JSQR = tmpreg1;
 1731              		.loc 1 1010 0
 1732 08d2 7B68     		ldr	r3, [r7, #4]
 1733 08d4 FA68     		ldr	r2, [r7, #12]
 1734 08d6 9A63     		str	r2, [r3, #56]
1011:../src/stm32f10x_adc.c **** }
 1735              		.loc 1 1011 0
 1736 08d8 07F11407 		add	r7, r7, #20
 1737 08dc BD46     		mov	sp, r7
 1738 08de 80BC     		pop	{r7}
 1739 08e0 7047     		bx	lr
 1740              		.cfi_endproc
 1741              	.LFE54:
 1743 08e2 00BF     		.align	2
 1744              		.global	ADC_SetInjectedOffset
 1745              		.thumb
 1746              		.thumb_func
 1748              	ADC_SetInjectedOffset:
 1749              	.LFB55:
1012:../src/stm32f10x_adc.c **** 
1013:../src/stm32f10x_adc.c **** /**
1014:../src/stm32f10x_adc.c ****   * @brief  Set the injected channels conversion value offset
1015:../src/stm32f10x_adc.c ****   * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
1016:../src/stm32f10x_adc.c ****   * @param  ADC_InjectedChannel: the ADC injected channel to set its offset. 
1017:../src/stm32f10x_adc.c ****   *   This parameter can be one of the following values:
1018:../src/stm32f10x_adc.c ****   *     @arg ADC_InjectedChannel_1: Injected Channel1 selected
1019:../src/stm32f10x_adc.c ****   *     @arg ADC_InjectedChannel_2: Injected Channel2 selected
1020:../src/stm32f10x_adc.c ****   *     @arg ADC_InjectedChannel_3: Injected Channel3 selected
1021:../src/stm32f10x_adc.c ****   *     @arg ADC_InjectedChannel_4: Injected Channel4 selected
1022:../src/stm32f10x_adc.c ****   * @param  Offset: the offset value for the selected ADC injected channel
1023:../src/stm32f10x_adc.c ****   *   This parameter must be a 12bit value.
1024:../src/stm32f10x_adc.c ****   * @retval None
1025:../src/stm32f10x_adc.c ****   */
1026:../src/stm32f10x_adc.c **** void ADC_SetInjectedOffset(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel, uint16_t Offset)
1027:../src/stm32f10x_adc.c **** {
 1750              		.loc 1 1027 0
 1751              		.cfi_startproc
 1752              		@ args = 0, pretend = 0, frame = 16
 1753              		@ frame_needed = 1, uses_anonymous_args = 0
 1754              		@ link register save eliminated.
 1755 08e4 80B4     		push	{r7}
 1756              	.LCFI77:
 1757              		.cfi_def_cfa_offset 4
 1758              		.cfi_offset 7, -4
 1759 08e6 85B0     		sub	sp, sp, #20
 1760              	.LCFI78:
 1761              		.cfi_def_cfa_offset 24
 1762 08e8 00AF     		add	r7, sp, #0
 1763              	.LCFI79:
 1764              		.cfi_def_cfa_register 7
 1765 08ea 7860     		str	r0, [r7, #4]
 1766 08ec 1346     		mov	r3, r2
 1767 08ee 0A46     		mov	r2, r1
 1768 08f0 FA70     		strb	r2, [r7, #3]
 1769 08f2 3B80     		strh	r3, [r7, #0]	@ movhi
1028:../src/stm32f10x_adc.c ****   __IO uint32_t tmp = 0;
 1770              		.loc 1 1028 0
 1771 08f4 4FF00003 		mov	r3, #0
 1772 08f8 FB60     		str	r3, [r7, #12]
1029:../src/stm32f10x_adc.c ****   
1030:../src/stm32f10x_adc.c ****   /* Check the parameters */
1031:../src/stm32f10x_adc.c ****   assert_param(IS_ADC_ALL_PERIPH(ADCx));
1032:../src/stm32f10x_adc.c ****   assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
1033:../src/stm32f10x_adc.c ****   assert_param(IS_ADC_OFFSET(Offset));  
1034:../src/stm32f10x_adc.c ****   
1035:../src/stm32f10x_adc.c ****   tmp = (uint32_t)ADCx;
 1773              		.loc 1 1035 0
 1774 08fa 7B68     		ldr	r3, [r7, #4]
 1775 08fc FB60     		str	r3, [r7, #12]
1036:../src/stm32f10x_adc.c ****   tmp += ADC_InjectedChannel;
 1776              		.loc 1 1036 0
 1777 08fe FA78     		ldrb	r2, [r7, #3]	@ zero_extendqisi2
 1778 0900 FB68     		ldr	r3, [r7, #12]
 1779 0902 D318     		adds	r3, r2, r3
 1780 0904 FB60     		str	r3, [r7, #12]
1037:../src/stm32f10x_adc.c ****   
1038:../src/stm32f10x_adc.c ****   /* Set the selected injected channel data offset */
1039:../src/stm32f10x_adc.c ****   *(__IO uint32_t *) tmp = (uint32_t)Offset;
 1781              		.loc 1 1039 0
 1782 0906 FB68     		ldr	r3, [r7, #12]
 1783 0908 3A88     		ldrh	r2, [r7, #0]
 1784 090a 1A60     		str	r2, [r3, #0]
1040:../src/stm32f10x_adc.c **** }
 1785              		.loc 1 1040 0
 1786 090c 07F11407 		add	r7, r7, #20
 1787 0910 BD46     		mov	sp, r7
 1788 0912 80BC     		pop	{r7}
 1789 0914 7047     		bx	lr
 1790              		.cfi_endproc
 1791              	.LFE55:
 1793 0916 00BF     		.align	2
 1794              		.global	ADC_GetInjectedConversionValue
 1795              		.thumb
 1796              		.thumb_func
 1798              	ADC_GetInjectedConversionValue:
 1799              	.LFB56:
1041:../src/stm32f10x_adc.c **** 
1042:../src/stm32f10x_adc.c **** /**
1043:../src/stm32f10x_adc.c ****   * @brief  Returns the ADC injected channel conversion result
1044:../src/stm32f10x_adc.c ****   * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
1045:../src/stm32f10x_adc.c ****   * @param  ADC_InjectedChannel: the converted ADC injected channel.
1046:../src/stm32f10x_adc.c ****   *   This parameter can be one of the following values:
1047:../src/stm32f10x_adc.c ****   *     @arg ADC_InjectedChannel_1: Injected Channel1 selected
1048:../src/stm32f10x_adc.c ****   *     @arg ADC_InjectedChannel_2: Injected Channel2 selected
1049:../src/stm32f10x_adc.c ****   *     @arg ADC_InjectedChannel_3: Injected Channel3 selected
1050:../src/stm32f10x_adc.c ****   *     @arg ADC_InjectedChannel_4: Injected Channel4 selected
1051:../src/stm32f10x_adc.c ****   * @retval The Data conversion value.
1052:../src/stm32f10x_adc.c ****   */
1053:../src/stm32f10x_adc.c **** uint16_t ADC_GetInjectedConversionValue(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel)
1054:../src/stm32f10x_adc.c **** {
 1800              		.loc 1 1054 0
 1801              		.cfi_startproc
 1802              		@ args = 0, pretend = 0, frame = 16
 1803              		@ frame_needed = 1, uses_anonymous_args = 0
 1804              		@ link register save eliminated.
 1805 0918 80B4     		push	{r7}
 1806              	.LCFI80:
 1807              		.cfi_def_cfa_offset 4
 1808              		.cfi_offset 7, -4
 1809 091a 85B0     		sub	sp, sp, #20
 1810              	.LCFI81:
 1811              		.cfi_def_cfa_offset 24
 1812 091c 00AF     		add	r7, sp, #0
 1813              	.LCFI82:
 1814              		.cfi_def_cfa_register 7
 1815 091e 7860     		str	r0, [r7, #4]
 1816 0920 0B46     		mov	r3, r1
 1817 0922 FB70     		strb	r3, [r7, #3]
1055:../src/stm32f10x_adc.c ****   __IO uint32_t tmp = 0;
 1818              		.loc 1 1055 0
 1819 0924 4FF00003 		mov	r3, #0
 1820 0928 FB60     		str	r3, [r7, #12]
1056:../src/stm32f10x_adc.c ****   
1057:../src/stm32f10x_adc.c ****   /* Check the parameters */
1058:../src/stm32f10x_adc.c ****   assert_param(IS_ADC_ALL_PERIPH(ADCx));
1059:../src/stm32f10x_adc.c ****   assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
1060:../src/stm32f10x_adc.c **** 
1061:../src/stm32f10x_adc.c ****   tmp = (uint32_t)ADCx;
 1821              		.loc 1 1061 0
 1822 092a 7B68     		ldr	r3, [r7, #4]
 1823 092c FB60     		str	r3, [r7, #12]
1062:../src/stm32f10x_adc.c ****   tmp += ADC_InjectedChannel + JDR_Offset;
 1824              		.loc 1 1062 0
 1825 092e FA78     		ldrb	r2, [r7, #3]	@ zero_extendqisi2
 1826 0930 FB68     		ldr	r3, [r7, #12]
 1827 0932 D318     		adds	r3, r2, r3
 1828 0934 03F12803 		add	r3, r3, #40
 1829 0938 FB60     		str	r3, [r7, #12]
1063:../src/stm32f10x_adc.c ****   
1064:../src/stm32f10x_adc.c ****   /* Returns the selected injected channel conversion data value */
1065:../src/stm32f10x_adc.c ****   return (uint16_t) (*(__IO uint32_t*)  tmp);   
 1830              		.loc 1 1065 0
 1831 093a FB68     		ldr	r3, [r7, #12]
 1832 093c 1B68     		ldr	r3, [r3, #0]
 1833 093e 9BB2     		uxth	r3, r3
1066:../src/stm32f10x_adc.c **** }
 1834              		.loc 1 1066 0
 1835 0940 1846     		mov	r0, r3
 1836 0942 07F11407 		add	r7, r7, #20
 1837 0946 BD46     		mov	sp, r7
 1838 0948 80BC     		pop	{r7}
 1839 094a 7047     		bx	lr
 1840              		.cfi_endproc
 1841              	.LFE56:
 1843              		.align	2
 1844              		.global	ADC_AnalogWatchdogCmd
 1845              		.thumb
 1846              		.thumb_func
 1848              	ADC_AnalogWatchdogCmd:
 1849              	.LFB57:
1067:../src/stm32f10x_adc.c **** 
1068:../src/stm32f10x_adc.c **** /**
1069:../src/stm32f10x_adc.c ****   * @brief  Enables or disables the analog watchdog on single/all regular
1070:../src/stm32f10x_adc.c ****   *         or injected channels
1071:../src/stm32f10x_adc.c ****   * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
1072:../src/stm32f10x_adc.c ****   * @param  ADC_AnalogWatchdog: the ADC analog watchdog configuration.
1073:../src/stm32f10x_adc.c ****   *   This parameter can be one of the following values:
1074:../src/stm32f10x_adc.c ****   *     @arg ADC_AnalogWatchdog_SingleRegEnable: Analog watchdog on a single regular channel
1075:../src/stm32f10x_adc.c ****   *     @arg ADC_AnalogWatchdog_SingleInjecEnable: Analog watchdog on a single injected channel
1076:../src/stm32f10x_adc.c ****   *     @arg ADC_AnalogWatchdog_SingleRegOrInjecEnable: Analog watchdog on a single regular or inje
1077:../src/stm32f10x_adc.c ****   *     @arg ADC_AnalogWatchdog_AllRegEnable: Analog watchdog on  all regular channel
1078:../src/stm32f10x_adc.c ****   *     @arg ADC_AnalogWatchdog_AllInjecEnable: Analog watchdog on  all injected channel
1079:../src/stm32f10x_adc.c ****   *     @arg ADC_AnalogWatchdog_AllRegAllInjecEnable: Analog watchdog on all regular and injected c
1080:../src/stm32f10x_adc.c ****   *     @arg ADC_AnalogWatchdog_None: No channel guarded by the analog watchdog
1081:../src/stm32f10x_adc.c ****   * @retval None	  
1082:../src/stm32f10x_adc.c ****   */
1083:../src/stm32f10x_adc.c **** void ADC_AnalogWatchdogCmd(ADC_TypeDef* ADCx, uint32_t ADC_AnalogWatchdog)
1084:../src/stm32f10x_adc.c **** {
 1850              		.loc 1 1084 0
 1851              		.cfi_startproc
 1852              		@ args = 0, pretend = 0, frame = 16
 1853              		@ frame_needed = 1, uses_anonymous_args = 0
 1854              		@ link register save eliminated.
 1855 094c 80B4     		push	{r7}
 1856              	.LCFI83:
 1857              		.cfi_def_cfa_offset 4
 1858              		.cfi_offset 7, -4
 1859 094e 85B0     		sub	sp, sp, #20
 1860              	.LCFI84:
 1861              		.cfi_def_cfa_offset 24
 1862 0950 00AF     		add	r7, sp, #0
 1863              	.LCFI85:
 1864              		.cfi_def_cfa_register 7
 1865 0952 7860     		str	r0, [r7, #4]
 1866 0954 3960     		str	r1, [r7, #0]
1085:../src/stm32f10x_adc.c ****   uint32_t tmpreg = 0;
 1867              		.loc 1 1085 0
 1868 0956 4FF00003 		mov	r3, #0
 1869 095a FB60     		str	r3, [r7, #12]
1086:../src/stm32f10x_adc.c ****   /* Check the parameters */
1087:../src/stm32f10x_adc.c ****   assert_param(IS_ADC_ALL_PERIPH(ADCx));
1088:../src/stm32f10x_adc.c ****   assert_param(IS_ADC_ANALOG_WATCHDOG(ADC_AnalogWatchdog));
1089:../src/stm32f10x_adc.c ****   /* Get the old register value */
1090:../src/stm32f10x_adc.c ****   tmpreg = ADCx->CR1;
 1870              		.loc 1 1090 0
 1871 095c 7B68     		ldr	r3, [r7, #4]
 1872 095e 5B68     		ldr	r3, [r3, #4]
 1873 0960 FB60     		str	r3, [r7, #12]
1091:../src/stm32f10x_adc.c ****   /* Clear AWDEN, AWDENJ and AWDSGL bits */
1092:../src/stm32f10x_adc.c ****   tmpreg &= CR1_AWDMode_Reset;
 1874              		.loc 1 1092 0
 1875 0962 FB68     		ldr	r3, [r7, #12]
 1876 0964 23F44003 		bic	r3, r3, #12582912
 1877 0968 23F40073 		bic	r3, r3, #512
 1878 096c FB60     		str	r3, [r7, #12]
1093:../src/stm32f10x_adc.c ****   /* Set the analog watchdog enable mode */
1094:../src/stm32f10x_adc.c ****   tmpreg |= ADC_AnalogWatchdog;
 1879              		.loc 1 1094 0
 1880 096e FA68     		ldr	r2, [r7, #12]
 1881 0970 3B68     		ldr	r3, [r7, #0]
 1882 0972 1343     		orrs	r3, r3, r2
 1883 0974 FB60     		str	r3, [r7, #12]
1095:../src/stm32f10x_adc.c ****   /* Store the new register value */
1096:../src/stm32f10x_adc.c ****   ADCx->CR1 = tmpreg;
 1884              		.loc 1 1096 0
 1885 0976 7B68     		ldr	r3, [r7, #4]
 1886 0978 FA68     		ldr	r2, [r7, #12]
 1887 097a 5A60     		str	r2, [r3, #4]
1097:../src/stm32f10x_adc.c **** }
 1888              		.loc 1 1097 0
 1889 097c 07F11407 		add	r7, r7, #20
 1890 0980 BD46     		mov	sp, r7
 1891 0982 80BC     		pop	{r7}
 1892 0984 7047     		bx	lr
 1893              		.cfi_endproc
 1894              	.LFE57:
 1896 0986 00BF     		.align	2
 1897              		.global	ADC_AnalogWatchdogThresholdsConfig
 1898              		.thumb
 1899              		.thumb_func
 1901              	ADC_AnalogWatchdogThresholdsConfig:
 1902              	.LFB58:
1098:../src/stm32f10x_adc.c **** 
1099:../src/stm32f10x_adc.c **** /**
1100:../src/stm32f10x_adc.c ****   * @brief  Configures the high and low thresholds of the analog watchdog.
1101:../src/stm32f10x_adc.c ****   * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
1102:../src/stm32f10x_adc.c ****   * @param  HighThreshold: the ADC analog watchdog High threshold value.
1103:../src/stm32f10x_adc.c ****   *   This parameter must be a 12bit value.
1104:../src/stm32f10x_adc.c ****   * @param  LowThreshold: the ADC analog watchdog Low threshold value.
1105:../src/stm32f10x_adc.c ****   *   This parameter must be a 12bit value.
1106:../src/stm32f10x_adc.c ****   * @retval None
1107:../src/stm32f10x_adc.c ****   */
1108:../src/stm32f10x_adc.c **** void ADC_AnalogWatchdogThresholdsConfig(ADC_TypeDef* ADCx, uint16_t HighThreshold,
1109:../src/stm32f10x_adc.c ****                                         uint16_t LowThreshold)
1110:../src/stm32f10x_adc.c **** {
 1903              		.loc 1 1110 0
 1904              		.cfi_startproc
 1905              		@ args = 0, pretend = 0, frame = 8
 1906              		@ frame_needed = 1, uses_anonymous_args = 0
 1907              		@ link register save eliminated.
 1908 0988 80B4     		push	{r7}
 1909              	.LCFI86:
 1910              		.cfi_def_cfa_offset 4
 1911              		.cfi_offset 7, -4
 1912 098a 83B0     		sub	sp, sp, #12
 1913              	.LCFI87:
 1914              		.cfi_def_cfa_offset 16
 1915 098c 00AF     		add	r7, sp, #0
 1916              	.LCFI88:
 1917              		.cfi_def_cfa_register 7
 1918 098e 7860     		str	r0, [r7, #4]
 1919 0990 1346     		mov	r3, r2
 1920 0992 0A46     		mov	r2, r1	@ movhi
 1921 0994 7A80     		strh	r2, [r7, #2]	@ movhi
 1922 0996 3B80     		strh	r3, [r7, #0]	@ movhi
1111:../src/stm32f10x_adc.c ****   /* Check the parameters */
1112:../src/stm32f10x_adc.c ****   assert_param(IS_ADC_ALL_PERIPH(ADCx));
1113:../src/stm32f10x_adc.c ****   assert_param(IS_ADC_THRESHOLD(HighThreshold));
1114:../src/stm32f10x_adc.c ****   assert_param(IS_ADC_THRESHOLD(LowThreshold));
1115:../src/stm32f10x_adc.c ****   /* Set the ADCx high threshold */
1116:../src/stm32f10x_adc.c ****   ADCx->HTR = HighThreshold;
 1923              		.loc 1 1116 0
 1924 0998 7A88     		ldrh	r2, [r7, #2]
 1925 099a 7B68     		ldr	r3, [r7, #4]
 1926 099c 5A62     		str	r2, [r3, #36]
1117:../src/stm32f10x_adc.c ****   /* Set the ADCx low threshold */
1118:../src/stm32f10x_adc.c ****   ADCx->LTR = LowThreshold;
 1927              		.loc 1 1118 0
 1928 099e 3A88     		ldrh	r2, [r7, #0]
 1929 09a0 7B68     		ldr	r3, [r7, #4]
 1930 09a2 9A62     		str	r2, [r3, #40]
1119:../src/stm32f10x_adc.c **** }
 1931              		.loc 1 1119 0
 1932 09a4 07F10C07 		add	r7, r7, #12
 1933 09a8 BD46     		mov	sp, r7
 1934 09aa 80BC     		pop	{r7}
 1935 09ac 7047     		bx	lr
 1936              		.cfi_endproc
 1937              	.LFE58:
 1939 09ae 00BF     		.align	2
 1940              		.global	ADC_AnalogWatchdogSingleChannelConfig
 1941              		.thumb
 1942              		.thumb_func
 1944              	ADC_AnalogWatchdogSingleChannelConfig:
 1945              	.LFB59:
1120:../src/stm32f10x_adc.c **** 
1121:../src/stm32f10x_adc.c **** /**
1122:../src/stm32f10x_adc.c ****   * @brief  Configures the analog watchdog guarded single channel
1123:../src/stm32f10x_adc.c ****   * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
1124:../src/stm32f10x_adc.c ****   * @param  ADC_Channel: the ADC channel to configure for the analog watchdog. 
1125:../src/stm32f10x_adc.c ****   *   This parameter can be one of the following values:
1126:../src/stm32f10x_adc.c ****   *     @arg ADC_Channel_0: ADC Channel0 selected
1127:../src/stm32f10x_adc.c ****   *     @arg ADC_Channel_1: ADC Channel1 selected
1128:../src/stm32f10x_adc.c ****   *     @arg ADC_Channel_2: ADC Channel2 selected
1129:../src/stm32f10x_adc.c ****   *     @arg ADC_Channel_3: ADC Channel3 selected
1130:../src/stm32f10x_adc.c ****   *     @arg ADC_Channel_4: ADC Channel4 selected
1131:../src/stm32f10x_adc.c ****   *     @arg ADC_Channel_5: ADC Channel5 selected
1132:../src/stm32f10x_adc.c ****   *     @arg ADC_Channel_6: ADC Channel6 selected
1133:../src/stm32f10x_adc.c ****   *     @arg ADC_Channel_7: ADC Channel7 selected
1134:../src/stm32f10x_adc.c ****   *     @arg ADC_Channel_8: ADC Channel8 selected
1135:../src/stm32f10x_adc.c ****   *     @arg ADC_Channel_9: ADC Channel9 selected
1136:../src/stm32f10x_adc.c ****   *     @arg ADC_Channel_10: ADC Channel10 selected
1137:../src/stm32f10x_adc.c ****   *     @arg ADC_Channel_11: ADC Channel11 selected
1138:../src/stm32f10x_adc.c ****   *     @arg ADC_Channel_12: ADC Channel12 selected
1139:../src/stm32f10x_adc.c ****   *     @arg ADC_Channel_13: ADC Channel13 selected
1140:../src/stm32f10x_adc.c ****   *     @arg ADC_Channel_14: ADC Channel14 selected
1141:../src/stm32f10x_adc.c ****   *     @arg ADC_Channel_15: ADC Channel15 selected
1142:../src/stm32f10x_adc.c ****   *     @arg ADC_Channel_16: ADC Channel16 selected
1143:../src/stm32f10x_adc.c ****   *     @arg ADC_Channel_17: ADC Channel17 selected
1144:../src/stm32f10x_adc.c ****   * @retval None
1145:../src/stm32f10x_adc.c ****   */
1146:../src/stm32f10x_adc.c **** void ADC_AnalogWatchdogSingleChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel)
1147:../src/stm32f10x_adc.c **** {
 1946              		.loc 1 1147 0
 1947              		.cfi_startproc
 1948              		@ args = 0, pretend = 0, frame = 16
 1949              		@ frame_needed = 1, uses_anonymous_args = 0
 1950              		@ link register save eliminated.
 1951 09b0 80B4     		push	{r7}
 1952              	.LCFI89:
 1953              		.cfi_def_cfa_offset 4
 1954              		.cfi_offset 7, -4
 1955 09b2 85B0     		sub	sp, sp, #20
 1956              	.LCFI90:
 1957              		.cfi_def_cfa_offset 24
 1958 09b4 00AF     		add	r7, sp, #0
 1959              	.LCFI91:
 1960              		.cfi_def_cfa_register 7
 1961 09b6 7860     		str	r0, [r7, #4]
 1962 09b8 0B46     		mov	r3, r1
 1963 09ba FB70     		strb	r3, [r7, #3]
1148:../src/stm32f10x_adc.c ****   uint32_t tmpreg = 0;
 1964              		.loc 1 1148 0
 1965 09bc 4FF00003 		mov	r3, #0
 1966 09c0 FB60     		str	r3, [r7, #12]
1149:../src/stm32f10x_adc.c ****   /* Check the parameters */
1150:../src/stm32f10x_adc.c ****   assert_param(IS_ADC_ALL_PERIPH(ADCx));
1151:../src/stm32f10x_adc.c ****   assert_param(IS_ADC_CHANNEL(ADC_Channel));
1152:../src/stm32f10x_adc.c ****   /* Get the old register value */
1153:../src/stm32f10x_adc.c ****   tmpreg = ADCx->CR1;
 1967              		.loc 1 1153 0
 1968 09c2 7B68     		ldr	r3, [r7, #4]
 1969 09c4 5B68     		ldr	r3, [r3, #4]
 1970 09c6 FB60     		str	r3, [r7, #12]
1154:../src/stm32f10x_adc.c ****   /* Clear the Analog watchdog channel select bits */
1155:../src/stm32f10x_adc.c ****   tmpreg &= CR1_AWDCH_Reset;
 1971              		.loc 1 1155 0
 1972 09c8 FB68     		ldr	r3, [r7, #12]
 1973 09ca 23F01F03 		bic	r3, r3, #31
 1974 09ce FB60     		str	r3, [r7, #12]
1156:../src/stm32f10x_adc.c ****   /* Set the Analog watchdog channel */
1157:../src/stm32f10x_adc.c ****   tmpreg |= ADC_Channel;
 1975              		.loc 1 1157 0
 1976 09d0 FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 1977 09d2 FA68     		ldr	r2, [r7, #12]
 1978 09d4 1343     		orrs	r3, r3, r2
 1979 09d6 FB60     		str	r3, [r7, #12]
1158:../src/stm32f10x_adc.c ****   /* Store the new register value */
1159:../src/stm32f10x_adc.c ****   ADCx->CR1 = tmpreg;
 1980              		.loc 1 1159 0
 1981 09d8 7B68     		ldr	r3, [r7, #4]
 1982 09da FA68     		ldr	r2, [r7, #12]
 1983 09dc 5A60     		str	r2, [r3, #4]
1160:../src/stm32f10x_adc.c **** }
 1984              		.loc 1 1160 0
 1985 09de 07F11407 		add	r7, r7, #20
 1986 09e2 BD46     		mov	sp, r7
 1987 09e4 80BC     		pop	{r7}
 1988 09e6 7047     		bx	lr
 1989              		.cfi_endproc
 1990              	.LFE59:
 1992              		.align	2
 1993              		.global	ADC_TempSensorVrefintCmd
 1994              		.thumb
 1995              		.thumb_func
 1997              	ADC_TempSensorVrefintCmd:
 1998              	.LFB60:
1161:../src/stm32f10x_adc.c **** 
1162:../src/stm32f10x_adc.c **** /**
1163:../src/stm32f10x_adc.c ****   * @brief  Enables or disables the temperature sensor and Vrefint channel.
1164:../src/stm32f10x_adc.c ****   * @param  NewState: new state of the temperature sensor.
1165:../src/stm32f10x_adc.c ****   *   This parameter can be: ENABLE or DISABLE.
1166:../src/stm32f10x_adc.c ****   * @retval None
1167:../src/stm32f10x_adc.c ****   */
1168:../src/stm32f10x_adc.c **** void ADC_TempSensorVrefintCmd(FunctionalState NewState)
1169:../src/stm32f10x_adc.c **** {
 1999              		.loc 1 1169 0
 2000              		.cfi_startproc
 2001              		@ args = 0, pretend = 0, frame = 8
 2002              		@ frame_needed = 1, uses_anonymous_args = 0
 2003              		@ link register save eliminated.
 2004 09e8 80B4     		push	{r7}
 2005              	.LCFI92:
 2006              		.cfi_def_cfa_offset 4
 2007              		.cfi_offset 7, -4
 2008 09ea 83B0     		sub	sp, sp, #12
 2009              	.LCFI93:
 2010              		.cfi_def_cfa_offset 16
 2011 09ec 00AF     		add	r7, sp, #0
 2012              	.LCFI94:
 2013              		.cfi_def_cfa_register 7
 2014 09ee 0346     		mov	r3, r0
 2015 09f0 FB71     		strb	r3, [r7, #7]
1170:../src/stm32f10x_adc.c ****   /* Check the parameters */
1171:../src/stm32f10x_adc.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
1172:../src/stm32f10x_adc.c ****   if (NewState != DISABLE)
 2016              		.loc 1 1172 0
 2017 09f2 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 2018 09f4 002B     		cmp	r3, #0
 2019 09f6 0CD0     		beq	.L71
1173:../src/stm32f10x_adc.c ****   {
1174:../src/stm32f10x_adc.c ****     /* Enable the temperature sensor and Vrefint channel*/
1175:../src/stm32f10x_adc.c ****     ADC1->CR2 |= CR2_TSVREFE_Set;
 2020              		.loc 1 1175 0
 2021 09f8 4FF41053 		mov	r3, #9216
 2022 09fc C4F20103 		movt	r3, 16385
 2023 0a00 4FF41052 		mov	r2, #9216
 2024 0a04 C4F20102 		movt	r2, 16385
 2025 0a08 9268     		ldr	r2, [r2, #8]
 2026 0a0a 42F40002 		orr	r2, r2, #8388608
 2027 0a0e 9A60     		str	r2, [r3, #8]
 2028 0a10 0BE0     		b	.L70
 2029              	.L71:
1176:../src/stm32f10x_adc.c ****   }
1177:../src/stm32f10x_adc.c ****   else
1178:../src/stm32f10x_adc.c ****   {
1179:../src/stm32f10x_adc.c ****     /* Disable the temperature sensor and Vrefint channel*/
1180:../src/stm32f10x_adc.c ****     ADC1->CR2 &= CR2_TSVREFE_Reset;
 2030              		.loc 1 1180 0
 2031 0a12 4FF41053 		mov	r3, #9216
 2032 0a16 C4F20103 		movt	r3, 16385
 2033 0a1a 4FF41052 		mov	r2, #9216
 2034 0a1e C4F20102 		movt	r2, 16385
 2035 0a22 9268     		ldr	r2, [r2, #8]
 2036 0a24 22F40002 		bic	r2, r2, #8388608
 2037 0a28 9A60     		str	r2, [r3, #8]
 2038              	.L70:
1181:../src/stm32f10x_adc.c ****   }
1182:../src/stm32f10x_adc.c **** }
 2039              		.loc 1 1182 0
 2040 0a2a 07F10C07 		add	r7, r7, #12
 2041 0a2e BD46     		mov	sp, r7
 2042 0a30 80BC     		pop	{r7}
 2043 0a32 7047     		bx	lr
 2044              		.cfi_endproc
 2045              	.LFE60:
 2047              		.align	2
 2048              		.global	ADC_GetFlagStatus
 2049              		.thumb
 2050              		.thumb_func
 2052              	ADC_GetFlagStatus:
 2053              	.LFB61:
1183:../src/stm32f10x_adc.c **** 
1184:../src/stm32f10x_adc.c **** /**
1185:../src/stm32f10x_adc.c ****   * @brief  Checks whether the specified ADC flag is set or not.
1186:../src/stm32f10x_adc.c ****   * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
1187:../src/stm32f10x_adc.c ****   * @param  ADC_FLAG: specifies the flag to check. 
1188:../src/stm32f10x_adc.c ****   *   This parameter can be one of the following values:
1189:../src/stm32f10x_adc.c ****   *     @arg ADC_FLAG_AWD: Analog watchdog flag
1190:../src/stm32f10x_adc.c ****   *     @arg ADC_FLAG_EOC: End of conversion flag
1191:../src/stm32f10x_adc.c ****   *     @arg ADC_FLAG_JEOC: End of injected group conversion flag
1192:../src/stm32f10x_adc.c ****   *     @arg ADC_FLAG_JSTRT: Start of injected group conversion flag
1193:../src/stm32f10x_adc.c ****   *     @arg ADC_FLAG_STRT: Start of regular group conversion flag
1194:../src/stm32f10x_adc.c ****   * @retval The new state of ADC_FLAG (SET or RESET).
1195:../src/stm32f10x_adc.c ****   */
1196:../src/stm32f10x_adc.c **** FlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, uint8_t ADC_FLAG)
1197:../src/stm32f10x_adc.c **** {
 2054              		.loc 1 1197 0
 2055              		.cfi_startproc
 2056              		@ args = 0, pretend = 0, frame = 16
 2057              		@ frame_needed = 1, uses_anonymous_args = 0
 2058              		@ link register save eliminated.
 2059 0a34 80B4     		push	{r7}
 2060              	.LCFI95:
 2061              		.cfi_def_cfa_offset 4
 2062              		.cfi_offset 7, -4
 2063 0a36 85B0     		sub	sp, sp, #20
 2064              	.LCFI96:
 2065              		.cfi_def_cfa_offset 24
 2066 0a38 00AF     		add	r7, sp, #0
 2067              	.LCFI97:
 2068              		.cfi_def_cfa_register 7
 2069 0a3a 7860     		str	r0, [r7, #4]
 2070 0a3c 0B46     		mov	r3, r1
 2071 0a3e FB70     		strb	r3, [r7, #3]
1198:../src/stm32f10x_adc.c ****   FlagStatus bitstatus = RESET;
 2072              		.loc 1 1198 0
 2073 0a40 4FF00003 		mov	r3, #0
 2074 0a44 FB73     		strb	r3, [r7, #15]
1199:../src/stm32f10x_adc.c ****   /* Check the parameters */
1200:../src/stm32f10x_adc.c ****   assert_param(IS_ADC_ALL_PERIPH(ADCx));
1201:../src/stm32f10x_adc.c ****   assert_param(IS_ADC_GET_FLAG(ADC_FLAG));
1202:../src/stm32f10x_adc.c ****   /* Check the status of the specified ADC flag */
1203:../src/stm32f10x_adc.c ****   if ((ADCx->SR & ADC_FLAG) != (uint8_t)RESET)
 2075              		.loc 1 1203 0
 2076 0a46 7B68     		ldr	r3, [r7, #4]
 2077 0a48 1B68     		ldr	r3, [r3, #0]
 2078 0a4a 1A46     		mov	r2, r3
 2079 0a4c FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 2080 0a4e 1340     		ands	r3, r3, r2
 2081 0a50 002B     		cmp	r3, #0
 2082 0a52 03D0     		beq	.L74
1204:../src/stm32f10x_adc.c ****   {
1205:../src/stm32f10x_adc.c ****     /* ADC_FLAG is set */
1206:../src/stm32f10x_adc.c ****     bitstatus = SET;
 2083              		.loc 1 1206 0
 2084 0a54 4FF00103 		mov	r3, #1
 2085 0a58 FB73     		strb	r3, [r7, #15]
 2086 0a5a 02E0     		b	.L75
 2087              	.L74:
1207:../src/stm32f10x_adc.c ****   }
1208:../src/stm32f10x_adc.c ****   else
1209:../src/stm32f10x_adc.c ****   {
1210:../src/stm32f10x_adc.c ****     /* ADC_FLAG is reset */
1211:../src/stm32f10x_adc.c ****     bitstatus = RESET;
 2088              		.loc 1 1211 0
 2089 0a5c 4FF00003 		mov	r3, #0
 2090 0a60 FB73     		strb	r3, [r7, #15]
 2091              	.L75:
1212:../src/stm32f10x_adc.c ****   }
1213:../src/stm32f10x_adc.c ****   /* Return the ADC_FLAG status */
1214:../src/stm32f10x_adc.c ****   return  bitstatus;
 2092              		.loc 1 1214 0
 2093 0a62 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
1215:../src/stm32f10x_adc.c **** }
 2094              		.loc 1 1215 0
 2095 0a64 1846     		mov	r0, r3
 2096 0a66 07F11407 		add	r7, r7, #20
 2097 0a6a BD46     		mov	sp, r7
 2098 0a6c 80BC     		pop	{r7}
 2099 0a6e 7047     		bx	lr
 2100              		.cfi_endproc
 2101              	.LFE61:
 2103              		.align	2
 2104              		.global	ADC_ClearFlag
 2105              		.thumb
 2106              		.thumb_func
 2108              	ADC_ClearFlag:
 2109              	.LFB62:
1216:../src/stm32f10x_adc.c **** 
1217:../src/stm32f10x_adc.c **** /**
1218:../src/stm32f10x_adc.c ****   * @brief  Clears the ADCx's pending flags.
1219:../src/stm32f10x_adc.c ****   * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
1220:../src/stm32f10x_adc.c ****   * @param  ADC_FLAG: specifies the flag to clear. 
1221:../src/stm32f10x_adc.c ****   *   This parameter can be any combination of the following values:
1222:../src/stm32f10x_adc.c ****   *     @arg ADC_FLAG_AWD: Analog watchdog flag
1223:../src/stm32f10x_adc.c ****   *     @arg ADC_FLAG_EOC: End of conversion flag
1224:../src/stm32f10x_adc.c ****   *     @arg ADC_FLAG_JEOC: End of injected group conversion flag
1225:../src/stm32f10x_adc.c ****   *     @arg ADC_FLAG_JSTRT: Start of injected group conversion flag
1226:../src/stm32f10x_adc.c ****   *     @arg ADC_FLAG_STRT: Start of regular group conversion flag
1227:../src/stm32f10x_adc.c ****   * @retval None
1228:../src/stm32f10x_adc.c ****   */
1229:../src/stm32f10x_adc.c **** void ADC_ClearFlag(ADC_TypeDef* ADCx, uint8_t ADC_FLAG)
1230:../src/stm32f10x_adc.c **** {
 2110              		.loc 1 1230 0
 2111              		.cfi_startproc
 2112              		@ args = 0, pretend = 0, frame = 8
 2113              		@ frame_needed = 1, uses_anonymous_args = 0
 2114              		@ link register save eliminated.
 2115 0a70 80B4     		push	{r7}
 2116              	.LCFI98:
 2117              		.cfi_def_cfa_offset 4
 2118              		.cfi_offset 7, -4
 2119 0a72 83B0     		sub	sp, sp, #12
 2120              	.LCFI99:
 2121              		.cfi_def_cfa_offset 16
 2122 0a74 00AF     		add	r7, sp, #0
 2123              	.LCFI100:
 2124              		.cfi_def_cfa_register 7
 2125 0a76 7860     		str	r0, [r7, #4]
 2126 0a78 0B46     		mov	r3, r1
 2127 0a7a FB70     		strb	r3, [r7, #3]
1231:../src/stm32f10x_adc.c ****   /* Check the parameters */
1232:../src/stm32f10x_adc.c ****   assert_param(IS_ADC_ALL_PERIPH(ADCx));
1233:../src/stm32f10x_adc.c ****   assert_param(IS_ADC_CLEAR_FLAG(ADC_FLAG));
1234:../src/stm32f10x_adc.c ****   /* Clear the selected ADC flags */
1235:../src/stm32f10x_adc.c ****   ADCx->SR = ~(uint32_t)ADC_FLAG;
 2128              		.loc 1 1235 0
 2129 0a7c FB78     		ldrb	r3, [r7, #3]	@ zero_extendqisi2
 2130 0a7e 6FEA0302 		mvn	r2, r3
 2131 0a82 7B68     		ldr	r3, [r7, #4]
 2132 0a84 1A60     		str	r2, [r3, #0]
1236:../src/stm32f10x_adc.c **** }
 2133              		.loc 1 1236 0
 2134 0a86 07F10C07 		add	r7, r7, #12
 2135 0a8a BD46     		mov	sp, r7
 2136 0a8c 80BC     		pop	{r7}
 2137 0a8e 7047     		bx	lr
 2138              		.cfi_endproc
 2139              	.LFE62:
 2141              		.align	2
 2142              		.global	ADC_GetITStatus
 2143              		.thumb
 2144              		.thumb_func
 2146              	ADC_GetITStatus:
 2147              	.LFB63:
1237:../src/stm32f10x_adc.c **** 
1238:../src/stm32f10x_adc.c **** /**
1239:../src/stm32f10x_adc.c ****   * @brief  Checks whether the specified ADC interrupt has occurred or not.
1240:../src/stm32f10x_adc.c ****   * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
1241:../src/stm32f10x_adc.c ****   * @param  ADC_IT: specifies the ADC interrupt source to check. 
1242:../src/stm32f10x_adc.c ****   *   This parameter can be one of the following values:
1243:../src/stm32f10x_adc.c ****   *     @arg ADC_IT_EOC: End of conversion interrupt mask
1244:../src/stm32f10x_adc.c ****   *     @arg ADC_IT_AWD: Analog watchdog interrupt mask
1245:../src/stm32f10x_adc.c ****   *     @arg ADC_IT_JEOC: End of injected conversion interrupt mask
1246:../src/stm32f10x_adc.c ****   * @retval The new state of ADC_IT (SET or RESET).
1247:../src/stm32f10x_adc.c ****   */
1248:../src/stm32f10x_adc.c **** ITStatus ADC_GetITStatus(ADC_TypeDef* ADCx, uint16_t ADC_IT)
1249:../src/stm32f10x_adc.c **** {
 2148              		.loc 1 1249 0
 2149              		.cfi_startproc
 2150              		@ args = 0, pretend = 0, frame = 24
 2151              		@ frame_needed = 1, uses_anonymous_args = 0
 2152              		@ link register save eliminated.
 2153 0a90 80B4     		push	{r7}
 2154              	.LCFI101:
 2155              		.cfi_def_cfa_offset 4
 2156              		.cfi_offset 7, -4
 2157 0a92 87B0     		sub	sp, sp, #28
 2158              	.LCFI102:
 2159              		.cfi_def_cfa_offset 32
 2160 0a94 00AF     		add	r7, sp, #0
 2161              	.LCFI103:
 2162              		.cfi_def_cfa_register 7
 2163 0a96 7860     		str	r0, [r7, #4]
 2164 0a98 0B46     		mov	r3, r1
 2165 0a9a 7B80     		strh	r3, [r7, #2]	@ movhi
1250:../src/stm32f10x_adc.c ****   ITStatus bitstatus = RESET;
 2166              		.loc 1 1250 0
 2167 0a9c 4FF00003 		mov	r3, #0
 2168 0aa0 FB75     		strb	r3, [r7, #23]
1251:../src/stm32f10x_adc.c ****   uint32_t itmask = 0, enablestatus = 0;
 2169              		.loc 1 1251 0
 2170 0aa2 4FF00003 		mov	r3, #0
 2171 0aa6 3B61     		str	r3, [r7, #16]
 2172 0aa8 4FF00003 		mov	r3, #0
 2173 0aac FB60     		str	r3, [r7, #12]
1252:../src/stm32f10x_adc.c ****   /* Check the parameters */
1253:../src/stm32f10x_adc.c ****   assert_param(IS_ADC_ALL_PERIPH(ADCx));
1254:../src/stm32f10x_adc.c ****   assert_param(IS_ADC_GET_IT(ADC_IT));
1255:../src/stm32f10x_adc.c ****   /* Get the ADC IT index */
1256:../src/stm32f10x_adc.c ****   itmask = ADC_IT >> 8;
 2174              		.loc 1 1256 0
 2175 0aae 7B88     		ldrh	r3, [r7, #2]
 2176 0ab0 4FEA1323 		lsr	r3, r3, #8
 2177 0ab4 9BB2     		uxth	r3, r3
 2178 0ab6 3B61     		str	r3, [r7, #16]
1257:../src/stm32f10x_adc.c ****   /* Get the ADC_IT enable bit status */
1258:../src/stm32f10x_adc.c ****   enablestatus = (ADCx->CR1 & (uint8_t)ADC_IT) ;
 2179              		.loc 1 1258 0
 2180 0ab8 7B68     		ldr	r3, [r7, #4]
 2181 0aba 5B68     		ldr	r3, [r3, #4]
 2182 0abc 1A46     		mov	r2, r3
 2183 0abe 7B88     		ldrh	r3, [r7, #2]	@ movhi
 2184 0ac0 DBB2     		uxtb	r3, r3
 2185 0ac2 1340     		ands	r3, r3, r2
 2186 0ac4 FB60     		str	r3, [r7, #12]
1259:../src/stm32f10x_adc.c ****   /* Check the status of the specified ADC interrupt */
1260:../src/stm32f10x_adc.c ****   if (((ADCx->SR & itmask) != (uint32_t)RESET) && enablestatus)
 2187              		.loc 1 1260 0
 2188 0ac6 7B68     		ldr	r3, [r7, #4]
 2189 0ac8 1B68     		ldr	r3, [r3, #0]
 2190 0aca 1A46     		mov	r2, r3
 2191 0acc 3B69     		ldr	r3, [r7, #16]
 2192 0ace 1340     		ands	r3, r3, r2
 2193 0ad0 002B     		cmp	r3, #0
 2194 0ad2 06D0     		beq	.L78
 2195              		.loc 1 1260 0 is_stmt 0 discriminator 1
 2196 0ad4 FB68     		ldr	r3, [r7, #12]
 2197 0ad6 002B     		cmp	r3, #0
 2198 0ad8 03D0     		beq	.L78
1261:../src/stm32f10x_adc.c ****   {
1262:../src/stm32f10x_adc.c ****     /* ADC_IT is set */
1263:../src/stm32f10x_adc.c ****     bitstatus = SET;
 2199              		.loc 1 1263 0 is_stmt 1
 2200 0ada 4FF00103 		mov	r3, #1
 2201 0ade FB75     		strb	r3, [r7, #23]
 2202 0ae0 02E0     		b	.L79
 2203              	.L78:
1264:../src/stm32f10x_adc.c ****   }
1265:../src/stm32f10x_adc.c ****   else
1266:../src/stm32f10x_adc.c ****   {
1267:../src/stm32f10x_adc.c ****     /* ADC_IT is reset */
1268:../src/stm32f10x_adc.c ****     bitstatus = RESET;
 2204              		.loc 1 1268 0
 2205 0ae2 4FF00003 		mov	r3, #0
 2206 0ae6 FB75     		strb	r3, [r7, #23]
 2207              	.L79:
1269:../src/stm32f10x_adc.c ****   }
1270:../src/stm32f10x_adc.c ****   /* Return the ADC_IT status */
1271:../src/stm32f10x_adc.c ****   return  bitstatus;
 2208              		.loc 1 1271 0
 2209 0ae8 FB7D     		ldrb	r3, [r7, #23]	@ zero_extendqisi2
1272:../src/stm32f10x_adc.c **** }
 2210              		.loc 1 1272 0
 2211 0aea 1846     		mov	r0, r3
 2212 0aec 07F11C07 		add	r7, r7, #28
 2213 0af0 BD46     		mov	sp, r7
 2214 0af2 80BC     		pop	{r7}
 2215 0af4 7047     		bx	lr
 2216              		.cfi_endproc
 2217              	.LFE63:
 2219 0af6 00BF     		.align	2
 2220              		.global	ADC_ClearITPendingBit
 2221              		.thumb
 2222              		.thumb_func
 2224              	ADC_ClearITPendingBit:
 2225              	.LFB64:
1273:../src/stm32f10x_adc.c **** 
1274:../src/stm32f10x_adc.c **** /**
1275:../src/stm32f10x_adc.c ****   * @brief  Clears the ADCx's interrupt pending bits.
1276:../src/stm32f10x_adc.c ****   * @param  ADCx: where x can be 1, 2 or 3 to select the ADC peripheral.
1277:../src/stm32f10x_adc.c ****   * @param  ADC_IT: specifies the ADC interrupt pending bit to clear.
1278:../src/stm32f10x_adc.c ****   *   This parameter can be any combination of the following values:
1279:../src/stm32f10x_adc.c ****   *     @arg ADC_IT_EOC: End of conversion interrupt mask
1280:../src/stm32f10x_adc.c ****   *     @arg ADC_IT_AWD: Analog watchdog interrupt mask
1281:../src/stm32f10x_adc.c ****   *     @arg ADC_IT_JEOC: End of injected conversion interrupt mask
1282:../src/stm32f10x_adc.c ****   * @retval None
1283:../src/stm32f10x_adc.c ****   */
1284:../src/stm32f10x_adc.c **** void ADC_ClearITPendingBit(ADC_TypeDef* ADCx, uint16_t ADC_IT)
1285:../src/stm32f10x_adc.c **** {
 2226              		.loc 1 1285 0
 2227              		.cfi_startproc
 2228              		@ args = 0, pretend = 0, frame = 16
 2229              		@ frame_needed = 1, uses_anonymous_args = 0
 2230              		@ link register save eliminated.
 2231 0af8 80B4     		push	{r7}
 2232              	.LCFI104:
 2233              		.cfi_def_cfa_offset 4
 2234              		.cfi_offset 7, -4
 2235 0afa 85B0     		sub	sp, sp, #20
 2236              	.LCFI105:
 2237              		.cfi_def_cfa_offset 24
 2238 0afc 00AF     		add	r7, sp, #0
 2239              	.LCFI106:
 2240              		.cfi_def_cfa_register 7
 2241 0afe 7860     		str	r0, [r7, #4]
 2242 0b00 0B46     		mov	r3, r1
 2243 0b02 7B80     		strh	r3, [r7, #2]	@ movhi
1286:../src/stm32f10x_adc.c ****   uint8_t itmask = 0;
 2244              		.loc 1 1286 0
 2245 0b04 4FF00003 		mov	r3, #0
 2246 0b08 FB73     		strb	r3, [r7, #15]
1287:../src/stm32f10x_adc.c ****   /* Check the parameters */
1288:../src/stm32f10x_adc.c ****   assert_param(IS_ADC_ALL_PERIPH(ADCx));
1289:../src/stm32f10x_adc.c ****   assert_param(IS_ADC_IT(ADC_IT));
1290:../src/stm32f10x_adc.c ****   /* Get the ADC IT index */
1291:../src/stm32f10x_adc.c ****   itmask = (uint8_t)(ADC_IT >> 8);
 2247              		.loc 1 1291 0
 2248 0b0a 7B88     		ldrh	r3, [r7, #2]
 2249 0b0c 4FEA1323 		lsr	r3, r3, #8
 2250 0b10 9BB2     		uxth	r3, r3
 2251 0b12 FB73     		strb	r3, [r7, #15]
1292:../src/stm32f10x_adc.c ****   /* Clear the selected ADC interrupt pending bits */
1293:../src/stm32f10x_adc.c ****   ADCx->SR = ~(uint32_t)itmask;
 2252              		.loc 1 1293 0
 2253 0b14 FB7B     		ldrb	r3, [r7, #15]	@ zero_extendqisi2
 2254 0b16 6FEA0302 		mvn	r2, r3
 2255 0b1a 7B68     		ldr	r3, [r7, #4]
 2256 0b1c 1A60     		str	r2, [r3, #0]
1294:../src/stm32f10x_adc.c **** }
 2257              		.loc 1 1294 0
 2258 0b1e 07F11407 		add	r7, r7, #20
 2259 0b22 BD46     		mov	sp, r7
 2260 0b24 80BC     		pop	{r7}
 2261 0b26 7047     		bx	lr
 2262              		.cfi_endproc
 2263              	.LFE64:
 2265              	.Letext0:
 2266              		.file 2 "/home/jachu/elektronika/STM32/gcc-arm-none-eabi-4_6-2012q4/bin/../lib/gcc/arm-none-eabi/4
 2267              		.file 3 "/home/jachu/workspaceSTM/Sumo_STM/src/stm32f10x.h"
 2268              		.file 4 "/home/jachu/elektronika/STM32/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPerip
 2269              		.file 5 "/home/jachu/elektronika/STM32/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/CMSIS/CM3/CoreSupp
DEFINED SYMBOLS
                            *ABS*:00000000 stm32f10x_adc.c
     /tmp/ccsEBhPa.s:18     .text:00000000 $t
     /tmp/ccsEBhPa.s:23     .text:00000000 ADC_DeInit
     /tmp/ccsEBhPa.s:101    .text:00000088 ADC_Init
     /tmp/ccsEBhPa.s:217    .text:00000138 ADC_StructInit
     /tmp/ccsEBhPa.s:272    .text:0000017c ADC_Cmd
     /tmp/ccsEBhPa.s:324    .text:000001b4 ADC_DMACmd
     /tmp/ccsEBhPa.s:376    .text:000001ec ADC_ITConfig
     /tmp/ccsEBhPa.s:441    .text:00000238 ADC_ResetCalibration
     /tmp/ccsEBhPa.s:478    .text:00000258 ADC_GetResetCalibrationStatus
     /tmp/ccsEBhPa.s:530    .text:00000290 ADC_StartCalibration
     /tmp/ccsEBhPa.s:567    .text:000002b0 ADC_GetCalibrationStatus
     /tmp/ccsEBhPa.s:619    .text:000002e8 ADC_SoftwareStartConvCmd
     /tmp/ccsEBhPa.s:671    .text:00000320 ADC_GetSoftwareStartConvStatus
     /tmp/ccsEBhPa.s:723    .text:00000358 ADC_DiscModeChannelCountConfig
     /tmp/ccsEBhPa.s:784    .text:000003a4 ADC_DiscModeCmd
     /tmp/ccsEBhPa.s:836    .text:000003dc ADC_RegularChannelConfig
     /tmp/ccsEBhPa.s:1078   .text:00000598 ADC_ExternalTrigConvCmd
     /tmp/ccsEBhPa.s:1130   .text:000005d0 ADC_GetConversionValue
     /tmp/ccsEBhPa.s:1166   .text:000005ec ADC_GetDualModeConversionValue
     /tmp/ccsEBhPa.s:1197   .text:00000604 ADC_AutoInjectedConvCmd
     /tmp/ccsEBhPa.s:1249   .text:0000063c ADC_InjectedDiscModeCmd
     /tmp/ccsEBhPa.s:1301   .text:00000674 ADC_ExternalTrigInjectedConvConfig
     /tmp/ccsEBhPa.s:1353   .text:000006ac ADC_ExternalTrigInjectedConvCmd
     /tmp/ccsEBhPa.s:1405   .text:000006e4 ADC_SoftwareStartInjectedConvCmd
     /tmp/ccsEBhPa.s:1457   .text:0000071c ADC_GetSoftwareStartInjectedConvCmdStatus
     /tmp/ccsEBhPa.s:1509   .text:00000754 ADC_InjectedChannelConfig
     /tmp/ccsEBhPa.s:1687   .text:00000898 ADC_InjectedSequencerLengthConfig
     /tmp/ccsEBhPa.s:1748   .text:000008e4 ADC_SetInjectedOffset
     /tmp/ccsEBhPa.s:1798   .text:00000918 ADC_GetInjectedConversionValue
     /tmp/ccsEBhPa.s:1848   .text:0000094c ADC_AnalogWatchdogCmd
     /tmp/ccsEBhPa.s:1901   .text:00000988 ADC_AnalogWatchdogThresholdsConfig
     /tmp/ccsEBhPa.s:1944   .text:000009b0 ADC_AnalogWatchdogSingleChannelConfig
     /tmp/ccsEBhPa.s:1997   .text:000009e8 ADC_TempSensorVrefintCmd
     /tmp/ccsEBhPa.s:2052   .text:00000a34 ADC_GetFlagStatus
     /tmp/ccsEBhPa.s:2108   .text:00000a70 ADC_ClearFlag
     /tmp/ccsEBhPa.s:2146   .text:00000a90 ADC_GetITStatus
     /tmp/ccsEBhPa.s:2224   .text:00000af8 ADC_ClearITPendingBit
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
RCC_APB2PeriphResetCmd
